#define _GNU_SOURCE

#include <stdarg.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <string.h>
#include <fcntl.h>
#include <pthread.h>
#include <sched.h>
#include <unistd.h>
#include <sys/resource.h>

bool write_file(const char* file, const char* what, ...) {
	char buf[1024];
	va_list args;
	va_start(args, what);
	vsnprintf(buf, sizeof(buf), what, args);
	va_end(args);
	buf[sizeof(buf) - 1] = 0;
	int len = strlen(buf);

	int fd = open(file, O_WRONLY | O_CLOEXEC);
	if (fd == -1)
		return false;
	if (write(fd, buf, len) != len) {
		close(fd);
		return false;
	}
	close(fd);
	return true;
}

// Source: https://stackoverflow.com/a/4077000
#define FD_LIMIT 65535
int increase_fd_limit() {
  struct rlimit limit;

  /* Get max number of files. */
  if (getrlimit(RLIMIT_NOFILE, &limit) != 0) {
    printf("[-] getrlimit() failed with errno=%d\n", errno);
    return 1;
  }

#if DEBUGGING
  printf("[D] The soft rlimit is %llu\n", (unsigned long long) limit.rlim_cur);
  printf("[D] The hard rlimit is %llu\n", (unsigned long long) limit.rlim_max);
#endif

  limit.rlim_cur = FD_LIMIT;
  limit.rlim_max = FD_LIMIT;
  if (setrlimit(RLIMIT_NOFILE, &limit) != 0) {
    printf("[-] setrlimit() failed with errno=%d\n", errno);
    return 1;
  }

  /* Get max number of files. */
  if (getrlimit(RLIMIT_NOFILE, &limit) != 0) {
    printf("[-] getrlimit() failed with errno=%d\n", errno);
    return 1;
  }

#if DEBUGGING
  printf("[D] The new soft rlimit is %llu\n", (unsigned long long) limit.rlim_cur);
  printf("[D] The new hard rlimit is %llu\n", (unsigned long long) limit.rlim_max);
#endif

  if (limit.rlim_cur != FD_LIMIT || limit.rlim_max != FD_LIMIT) {
    printf("[-] Setting rlimit to %d failed.\n", FD_LIMIT);
    return 1;
  }

#if DEBUGGING
  /* Also children will be affected: */
  printf("[D] $ bash -c 'ulimit -a'\n");
  system("bash -c 'ulimit -a'");
#endif

  return 0;
}

void setup_sandbox() {
  int real_uid = getuid();
  int real_gid = getgid();

  if (unshare(CLONE_NEWUSER) != 0) {
    perror("[-] unshare(CLONE_NEWUSER)");
    exit(EXIT_FAILURE);
  }

  if (unshare(CLONE_NEWNET) != 0) {
    perror("[-] unshare(CLONE_NEWUSER)");
    exit(EXIT_FAILURE);
  }

  if (!write_file("/proc/self/setgroups", "deny")) {
    perror("[-] write_file(/proc/self/set_groups)");
    exit(EXIT_FAILURE);
  }
  if (!write_file("/proc/self/uid_map", "0 %d 1\n", real_uid)){
    perror("[-] write_file(/proc/self/uid_map)");
    exit(EXIT_FAILURE);
  }
  if (!write_file("/proc/self/gid_map", "0 %d 1\n", real_gid)) {
    perror("[-] write_file(/proc/self/gid_map)");
    exit(EXIT_FAILURE);
  }

  cpu_set_t my_set;
  CPU_ZERO(&my_set);
  CPU_SET(0, &my_set);
  if (sched_setaffinity(0, sizeof(my_set), &my_set) != 0) {
    perror("[-] sched_setaffinity()");
    exit(EXIT_FAILURE);
  }

  if (system("/sbin/ifconfig lo up") != 0) {
    perror("[-] system(/sbin/ifconfig lo up)");
    exit(EXIT_FAILURE);
  }

  if(increase_fd_limit()) {
    printf("[-] increasing fd limit failed");
    exit(EXIT_FAILURE);
  }

	printf("[.] namespace sandbox set up\n");
}

void set_cpu(int cpu_id) {
  cpu_set_t cpuset;

  CPU_ZERO(&cpuset);
  CPU_SET(cpu_id, &cpuset);

  int r = pthread_setaffinity_np(pthread_self(), sizeof(cpu_set_t), &cpuset);
  if (r != 0) {
    printf("[-] failed to set cpu affinity to %d\n", cpu_id);
    exit(1);
  }
}
