#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <math.h>
#include <sys/mman.h>
#include <stdbool.h>

#include "evsets_api.h"
#include "kmod_driver.h"
#include "llc_prime_probe.h"
#include "calib.h"

#define ASSERT(x) \
  do { if(!(x)) { \
    fprintf(stderr, "%s:%d: assert %s failed\n", __FILE__, __LINE__, #x); abort(); \
  } } while(0)

#define POOLPAGES   10000
#define REMOVED_TARGET_PAGE_IDX -1

#define MAX_EVICSET_CANDIDATES 1300

#define NUM_CORES 8

// HUGE memory region
// pages in this region are used to create eviction sets
static volatile char *pool = NULL;

// eviction_sets contains the found eviction sets
#define EVICTION_SETS 300
int eviction_sets[EVICTION_SETS][NUM_CACHELINES_IN_CACHESET];
int num_eviction_sets = 0;
int created_eviction_sets = 0;

typedef struct evicset_dll {
  volatile char *target; // points to an aligned-page address
  struct evicset_dll * next;
  struct evicset_dll * prev;
} evicset_dll_t;

// Eviction set addresses stored in a doubly linked list:
evicset_dll_t evicset_dll_arr[MAX_EVICSET_CANDIDATES];
int nfree_evicset_dll_arr; // rm / change name
evicset_dll_t *first, *last;

void create_evicset_dll(int *evicset, int num_evicset_items) {
	int i;
  evicset_dll_t *node_top = NULL, *node = NULL;

  ASSERT(num_evicset_items <= MAX_EVICSET_CANDIDATES);
	nfree_evicset_dll_arr = MAX_EVICSET_CANDIDATES; // this builds by starting at end
	first = last = NULL;

	for(i=0; i < num_evicset_items; i++) {
    if(evicset[i] == REMOVED_TARGET_PAGE_IDX) continue;

    nfree_evicset_dll_arr--;
    node = &evicset_dll_arr[nfree_evicset_dll_arr];

		node->prev = node_top;
		if(node_top) { node_top->next = node; }
		node_top = node;
		if(!first) { first = node_top; }

		node_top->target = (volatile char *) &pool[evicset[i] * PAGE_SIZE];
		node_top->next = NULL;
	}

	last = node_top;
}

void access_evicset_dll(int offset) {
	evicset_dll_t * e;
  asm __volatile__ (
    "mfence \n"
    "lfence \n"
    :::
  );
	for(e = first; e; e=e->next) {
		*(e->target+offset);
	}

	for(e = last; e; e=e->prev) {
		*(e->target+offset);
	}

	for(e = first; e; e=e->next) {
		*(e->target+offset);
	}

	for(e = last; e; e=e->prev) {
		*(e->target+offset);
	}
  asm __volatile__ (
    "mfence \n"
    "lfence \n"
    :::
  );
}

static inline uint64_t rdtsc(void) {
    uint64_t a, d;
    asm volatile ("rdtscp" : "=a" (a), "=d" (d) : : "rcx");
    a = (d<<32) | a;
    return a;
}

#define POOL_ALIGNMENT (1024*1024*2)
void init(){
  time_t t;
  srand((unsigned) time(&t));

  pool = mmap(NULL, POOLPAGES * PAGE_SIZE + POOL_ALIGNMENT, PROT_READ|PROT_WRITE,
              MAP_ANONYMOUS|MAP_PRIVATE, -1, 0);
  ASSERT(pool != MAP_FAILED);
  int off = (uint64_t) pool%POOL_ALIGNMENT;
  if(off) pool += (POOL_ALIGNMENT-off);
  memset((char *) pool, 0xf1, POOLPAGES * PAGE_SIZE);
}

// Source:
// See Table 3 in https://cmaurice.fr/pdf/raid15_maurice.pdf
int get_llc_slice(unsigned long long phys_addr, int num_cores){
  unsigned long long bit0 = 0;
  unsigned long long bit1 = 0;
  unsigned long long bit2 = 0;

  switch(num_cores){
    case 8:
      bit0 ^= (phys_addr & ((unsigned long long)1<<35)) >> 35;
      bit0 ^= (phys_addr & ((unsigned long long)1<<36)) >> 36;

      bit1 ^= (phys_addr & ((unsigned long long)1<<35)) >> 35;
      bit1 ^= (phys_addr & ((unsigned long long)1<<37)) >> 37;

      bit2 ^= (phys_addr & ((unsigned long long)1<<8))  >> 8;
      bit2 ^= (phys_addr & ((unsigned long long)1<<12)) >> 12;
      bit2 ^= (phys_addr & ((unsigned long long)1<<13)) >> 13;
      bit2 ^= (phys_addr & ((unsigned long long)1<<16)) >> 16;
      bit2 ^= (phys_addr & ((unsigned long long)1<<19)) >> 19;
      bit2 ^= (phys_addr & ((unsigned long long)1<<22)) >> 22;
      bit2 ^= (phys_addr & ((unsigned long long)1<<23)) >> 23;
      bit2 ^= (phys_addr & ((unsigned long long)1<<26)) >> 26;
      bit2 ^= (phys_addr & ((unsigned long long)1<<27)) >> 27;
      bit2 ^= (phys_addr & ((unsigned long long)1<<30)) >> 30;
      bit2 ^= (phys_addr & ((unsigned long long)1<<31)) >> 31;
      bit2 ^= (phys_addr & ((unsigned long long)1<<34)) >> 34;
      bit2 ^= (phys_addr & ((unsigned long long)1<<35)) >> 35;
      bit2 ^= (phys_addr & ((unsigned long long)1<<36)) >> 36;
      bit2 ^= (phys_addr & ((unsigned long long)1<<37)) >> 37;
    case 4:
      bit0 ^= (phys_addr & ((unsigned long long)1<<33)) >> 33;

      bit1 ^= (phys_addr & ((unsigned long long)1<<7))  >> 7;
      bit1 ^= (phys_addr & ((unsigned long long)1<<11)) >> 11;
      bit1 ^= (phys_addr & ((unsigned long long)1<<13)) >> 13;
      bit1 ^= (phys_addr & ((unsigned long long)1<<15)) >> 15;
      bit1 ^= (phys_addr & ((unsigned long long)1<<17)) >> 17;
      bit1 ^= (phys_addr & ((unsigned long long)1<<19)) >> 19;
      bit1 ^= (phys_addr & ((unsigned long long)1<<20)) >> 20;
      bit1 ^= (phys_addr & ((unsigned long long)1<<21)) >> 21;
      bit1 ^= (phys_addr & ((unsigned long long)1<<22)) >> 22;
      bit1 ^= (phys_addr & ((unsigned long long)1<<23)) >> 23;
      bit1 ^= (phys_addr & ((unsigned long long)1<<24)) >> 24;
      bit1 ^= (phys_addr & ((unsigned long long)1<<26)) >> 26;
      bit1 ^= (phys_addr & ((unsigned long long)1<<28)) >> 28;
      bit1 ^= (phys_addr & ((unsigned long long)1<<29)) >> 29;
      bit1 ^= (phys_addr & ((unsigned long long)1<<31)) >> 31;
      bit1 ^= (phys_addr & ((unsigned long long)1<<33)) >> 33;
      bit1 ^= (phys_addr & ((unsigned long long)1<<34)) >> 34;
    case 2:
      bit0 ^= (phys_addr & ((unsigned long long)1<<6))  >> 6;
      bit0 ^= (phys_addr & ((unsigned long long)1<<10)) >> 10;
      bit0 ^= (phys_addr & ((unsigned long long)1<<12)) >> 12;
      bit0 ^= (phys_addr & ((unsigned long long)1<<14)) >> 14;
      bit0 ^= (phys_addr & ((unsigned long long)1<<16)) >> 16;
      bit0 ^= (phys_addr & ((unsigned long long)1<<17)) >> 17;
      bit0 ^= (phys_addr & ((unsigned long long)1<<18)) >> 18;
      bit0 ^= (phys_addr & ((unsigned long long)1<<20)) >> 20;
      bit0 ^= (phys_addr & ((unsigned long long)1<<22)) >> 22;
      bit0 ^= (phys_addr & ((unsigned long long)1<<24)) >> 24;
      bit0 ^= (phys_addr & ((unsigned long long)1<<25)) >> 25;
      bit0 ^= (phys_addr & ((unsigned long long)1<<26)) >> 26;
      bit0 ^= (phys_addr & ((unsigned long long)1<<27)) >> 27;
      bit0 ^= (phys_addr & ((unsigned long long)1<<28)) >> 28;
      bit0 ^= (phys_addr & ((unsigned long long)1<<30)) >> 30;
      bit0 ^= (phys_addr & ((unsigned long long)1<<32)) >> 32;
      break;
    default:
      fprintf(stderr, "Num cores (%d) not supported.\n", num_cores);
      exit(1);
  }

  return (int) (bit0 + (bit1<<1) + (bit2<<2) );
}

int get_set_id(unsigned long long phys_addr, int num_cores){
  // Assuming 8192 cache sets and 64b cachelines.
  // To grab the log2(8192/4[cores])=11 bits starting from bit 6 (2**6==64):
  int mask = (((unsigned long long)1 << (int)log2(8192/num_cores)) - 1) << 6;

  return (int)((phys_addr & mask) >> 6);
}

int get_evicset_idx(unsigned long long phys_addr, int num_cores){
  // With 8MB cache, 64b cachelines, 16 LLC_WAYS, and 64 cachelines per page
  // we have 128 eviction sets
  return get_llc_slice(phys_addr,num_cores)*(128/num_cores)
          + get_set_id(phys_addr,num_cores)/64; // 64 cachelines per page
}

int count_selected_pages[128];
void create_evicsets_with_kmod(){
  int total_pages = 128 * 16; // 128 eviction sets, 16 cachelines
  int saved_pages = 0;
  int page_idx = 0;
  void *virt_addr;
  void *phys_addr;
  int num_cores = NUM_CORES;

  memset(count_selected_pages,0,sizeof(count_selected_pages));

  while(saved_pages < total_pages){
    virt_addr = (void*)&pool[0x1000 * page_idx];
    if(kd_get_phys_addr(virt_addr, &phys_addr)){
      fprintf(stderr, "Virt to phys addr translation failed. exiting..\n");
      exit(1);
    }
    int evicset_idx = get_evicset_idx((unsigned long long)phys_addr, num_cores);
    if(count_selected_pages[evicset_idx] < LLC_WAYS){
      eviction_sets[evicset_idx][count_selected_pages[evicset_idx]] = page_idx;
      count_selected_pages[evicset_idx] += 1;
      saved_pages += 1;
    }

    page_idx += 1;
  }

  num_eviction_sets = 128;
  created_eviction_sets = 1;
}

int last_primed_evicset_idx = -1;

void create_evicset_dll_evsets(Elem *evset) {
  evicset_dll_t *node_top = NULL, *node = NULL;

  nfree_evicset_dll_arr = MAX_EVICSET_CANDIDATES; // this builds by starting at end
  first = last = NULL;

  while (evset) {
    nfree_evicset_dll_arr--;
    node = &evicset_dll_arr[nfree_evicset_dll_arr];

    node->prev = node_top;
    if(node_top) { node_top->next = node; }
    node_top = node;
    if(!first) { first = node_top; }

    node_top->target = (volatile char *) evset;
    node_top->next = NULL;

    evset = evset->next;
  }

  last = node_top;
}

#define GEN_METHOD_EVSETS 1
#define GEN_METHOD_KMOD 2
int __gen_method = 0;
int __llc_cache_size = 0;
int __llc_associativity = 0;

int __create_eviction_sets() {
  struct config evsets_conf = {
    .rounds = 10,
    .cal_rounds = 1000000,
    .stride = 4096,
    .cache_size = __llc_cache_size << 20,
    .cache_way = __llc_associativity,
    .cache_slices = 4,
    .ignoreslice = true,
    .verbose = false,
    .no_huge_pages = true,
    .calibrate = true,
    .algorithm = ALGORITHM_GROUP,
    .strategy = 2,
    .offset = 0,
    .retry = true,
    .backtracking = true,
    .verify = false,
    .debug = false,
    .con = 0,
    .noncon = 0,
    .ratio = -1.0,
    // calculate #pages that fit in LLC and double that number:
    .buffer_size = (__llc_cache_size << 20) / 4096 * 2,
    .findallcolors = true,
    .findallcongruent = false,
    .conflictset = false,
  };

  switch (__gen_method) {
    case GEN_METHOD_EVSETS:
      if (init_evsets(&evsets_conf)) {
        printf("[-] init_evsets failed\n");
        return 1;
      }

      if (find_evsets()) {
        printf("[-] find_evsets failed\n");
        close_evsets();
        return 1;
      }

      num_eviction_sets = get_num_evsets();
      atexit(close_evsets);
      break;

    case GEN_METHOD_KMOD:
      init();
      create_evicsets_with_kmod();
      ASSERT(num_eviction_sets == EXPECTED_NUM_EVICTION_SETS);
      break;

    default:
      fprintf(stderr, "Provided library unrecognized..\n");
      return -1;
  }

  created_eviction_sets = 1;

  return 0;
}

int pp_create_eviction_sets(const char *evicset_gen_method, int llc_cache_size, int llc_associativity) {
  if (created_eviction_sets) {
    return 0;
  }

  if (!evicset_gen_method) {
    fprintf(stderr, "Missing prime probe library..\n");
    return -1;
  }

  if (llc_cache_size == 0 || llc_cache_size < 0) {
    fprintf(stderr, "Invalid cache size: %d\n", llc_cache_size);
    return -1;
  }

  if (llc_associativity == 0 || llc_associativity < 0) {
    fprintf(stderr, "Invalid cache associativity: %d\n", llc_associativity);
    return -1;
  }

  if (strcmp(evicset_gen_method, "evsets") == 0) {
    __gen_method = GEN_METHOD_EVSETS;
  } else if (strcmp(evicset_gen_method, "kmod") == 0) {
    __gen_method = GEN_METHOD_KMOD;
  } else {
    fprintf(stderr, "Provided library unrecognized..\n");
    return -1;
  }

  __llc_cache_size = llc_cache_size;
  __llc_associativity = llc_associativity;

  if (__create_eviction_sets()) {
    return 1;
  }

  return 0;
}

int pp_close() {
  if (!created_eviction_sets) {
    return 0;
  }

  if (__gen_method == GEN_METHOD_EVSETS) {
    close_evsets();
  } else if (__gen_method == GEN_METHOD_KMOD) {
    if (munmap((void*)pool, POOLPAGES * PAGE_SIZE + POOL_ALIGNMENT)) {
      perror("munmap");
      return 1;
    }
    pool = NULL;
  }

  created_eviction_sets = 0;
  num_eviction_sets = 0;
  last_primed_evicset_idx = -1;

  return 0;
}

int pp_get_evicset_pages(int evicset_idx, char **arr, int size) {
  if(!created_eviction_sets) {
    fprintf(stderr, "Error: eviction sets not available..\n");
    return -1;
  }

  int num_pages = 0;
  if (__gen_method == GEN_METHOD_EVSETS) {
    Elem* evset = get_evset(evicset_idx);

    while (evset && num_pages < size) {
      arr[num_pages] = (char*) evset;
      evset = evset->next;
      num_pages += 1;
    }
  } else if (__gen_method == GEN_METHOD_KMOD) {
    void *virt_addr;
    void *phys_addr;
    int num_cores = NUM_CORES;
    int page_idx = 0;

    while(num_pages < size){
      virt_addr = (void*)&pool[0x1000 * page_idx];
      if(kd_get_phys_addr(virt_addr, &phys_addr)){
        fprintf(stderr, "Virt to phys addr translation failed. exiting..\n");
        exit(1);
      }
      int page_evicset_idx = get_evicset_idx((unsigned long long)phys_addr, num_cores);
      if(evicset_idx == page_evicset_idx){
        arr[num_pages] = virt_addr;
        num_pages += 1;
      }

      page_idx += 1;
    }
  } else {
    fprintf(stderr, "Error: getting eviction set pages unavailable. evicset_gen_method:%d..\n", __gen_method);
    return -1;
  }

  return num_pages;
}

// avoiding error checking to keep noise minimal
void pp_prime_cacheset(int evicset_idx, int cacheset_idx) {
  evicset_idx = evicset_idx % num_eviction_sets;

  if(evicset_idx != last_primed_evicset_idx){
    if (__gen_method == GEN_METHOD_EVSETS) {
      create_evicset_dll_evsets(get_evset(evicset_idx));
    } else if (__gen_method == GEN_METHOD_KMOD){
      create_evicset_dll(eviction_sets[evicset_idx], NUM_CACHELINES_IN_CACHESET);
    }
  }

  access_evicset_dll(cacheset_idx * CACHELINE_SIZE);

  last_primed_evicset_idx = evicset_idx;
}

// ignoring error checking to keep noise minimal
unsigned long pp_probe_cacheset_access_time(int evicset_idx, int cacheset_idx) {
  evicset_dll_t * e;
  evicset_idx = evicset_idx % num_eviction_sets;

  int offset = cacheset_idx * CACHELINE_SIZE;

  asm __volatile__ (
    //"mfence \n"
    "lfence \n"
    :::
  );
  uint64_t t0 = rdtsc();
  asm __volatile__ (
    //"mfence \n"
    "lfence \n"
    :::
  );

  for(e = first; e; e=e->next){
    *(e->target + offset);
  }

  asm __volatile__ (
    //"mfence \n"
    "lfence \n"
    :::
  );

  return rdtsc() - t0;
}
